## 9.代码分离

> 我们的 js 都是打包输出到一个文件中的，当内容越来越多的时候，会导致单个文件体积十分巨大，所以我们就需要对代码进行分割，将一个巨大的文件，分割成多个中小型文件，然后可以按需加载或并行加载这些文件

代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大缩减加载时间。

**常用的代码分离方法有三种：**

- **入口起点**：使用 entry 配置手动地分离代码。
- **动态导入**：通过模块的内联函数调用来分离代码
- **防止重复**：使用 SplitChunksPlugin 去重和分离 chunk。

### 9.1 入口起点( 不推荐 )

使用 entry 配置手动分离代码，如果多个入口共享的文件，会分别在每个包里重复打包。

```js
module.exports = {
  entry: {
    main: './assets/js/main.js',
    other: './assets/js/add.js'
  },
  output: {
    filename: 'js/[name].bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
}
```

这种方式的确存在一些隐患：

- 如果入口 `chunk `之间包含一些重复的模块，那些重复模块都会被引入到各个 `bundle `中。
- 这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。

### 9.2 防止重复

**配置 entry 提取公用依赖**

`webpack.config.js`

```js
module.exports = {
  entry: {
    main: {
      import: './assets/js/main.js', // 启动时需加载的模块
      dependOn: 'shared' // 当前入口所依赖的入口
    },
    other: {
      import: './assets/js/add.js',
      dependOn: 'shared'
    },
    shared: 'lodash' // 当上面两个模块有lodash这个模块时，就提取出来并命名为shared chunk
  },
  output: {
    filename: 'js/[name].bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
}
```

执行`webpack`命令，可以看到打包结果

已经提取出来`shared.bundle.js，`即为提取打包了 lodash 公用模块

`index.bundle.js other.bundle.js`体积也变小

查看`dist/index.html`可以看到三个文件都被加载了

**SplitChunksPlugin**

`SplitChunksPlugin` 插件可以能自动的帮助我们做公共模块的抽离。让我们使用这个插件，将之前的示例中重 复的 lodash 模块去除：

webpack 中 splitChunks 的默认配置

```js
module.exports = {
  entry: {
    main: './assets/js/main.js',
    other: './assets/js/add.js'
  },
  output: {
    filename: 'js/[name].bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  optimization: {
    splitChunks: {
      chunks: 'all', // 动态导入的模块其依赖会根据规则分离
      minSize: 30000, // 文件体积要大于 30k
      minChunks: 1, // 文件至少被 1 个chunk 引用
      maxAsyncRequests: 5, // 动态导入文件最大并发请求数为 5
      maxInitialRequests: 3, // 入口文件最大并发请求数为 3
      automaticNameDelimiter: '~', // 文件名中的分隔符
      name: true, // 自动命名
      cacheGroups: {
        vendors: {
          // 分离第三方库
          test: /[\\/]node_modules[\\/]/,
          priority: -10 // 权重
        },
        default: {
          // 分离公共的文件
          minChunks: 2, // 文件至少被 2 个 chunk 引用
          priority: -20,
          reuseExistingChunk: true // 复用存在的 chunk
        }
      }
    }
  }
}
```

**chunks**

该参数有四种取值

- `async`：动态导入的文件其静态依赖会根据规则分离
- `initial`：入口文件的静态依赖会根据规则分离
- `all`：所有的都会根据规则分离
- `chunk => Boolean`：返回 true 表示根据规则分离，false 则不分离

更多配置查看： [SplitChunksPlugin](https://webpack.docschina.org/plugins/split-chunks-plugin/)

可以通过 import 方法对文件名进行自定义

```js
import(/* webpackChunkName: '自定义文件名' */ '文件路径')
```

### 9.3 动态导入

当涉及到动态代码拆分时，webpack 提供了两个类似的技术。

- 第一种，也是推荐选择的方式是，使用符合 ECMAScript 提案 的 `import() `语法 来实现动态导入。
- 第二种，则是 webpack 的遗留功能，使用 webpack 特定的 require.ensure 。

这里让我们尝试使用第一种方式，使用`import()`来进行动态导入

我们分别在 `index.html、other.js、index.js` 中添加如下代码

```js
// index.html body 中添加
;<button id='btn'>点我</button>

// other.js
console.log('我被加载了')

// index.js
let btn = document.querySelector('#btn')
btn.addEventListener('click', () => {
  // import() 返回的是一个 promise，在 then() 方法中执行导入后的操作，也可以使用 async/await
  import('./other').then((res) => {
    console.log(res)
  })
})
```

![image-20220803154417374](https://i0.hdslb.com/bfs/album/558cca88a0f6bd72416fff9b16f93bfda6f9f3ec.png)

可以看到，打包文件多生成了一个叫 `0.js `的文件，并且 html 中并没有引入该文件，点击按钮再看看会发生什么

![image-20220803154506870](https://i0.hdslb.com/bfs/album/98ed4250a9eff8936b74e7d5465c2a185f9aca64.png)

生成了一个 script 标签，并加载了 `0.js` 文件，这就是动态导入。对于这个文件名称，不是很直观，我们使用魔法注释修改一下

```js
import(/* webpackChunkName: "other" */ './other').then((res) => {
  console.log(res)
})
```

最终打包生成的文件名就叫 other.js，如果希望加上 hash 值，可以在配置文件里添加一个参数

```js
output: {
  filename: "[name].[chunkhash:10].js", // 入口文件打包生成的文件名
  chunkFilename: "[name].[chunkhash:10].js" // 动态模块打包生成的文件名，name 默认为数字，如果使用了魔法注释则为魔法注释的名字
}
```

### 9.4 懒加载

懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。

`math.js`

```js
export function add(x, y) {
  return x + y
}

export function reduce(x, y) {
  return x - y
}
```

`src/index.js`

```js
const button = document.createElement('button')
button.textContent = '点击执行加法运算'
button.addEventListener('click', () => {
  // 魔法注释 webpackChunkName 修改懒加载打包文件名
  // 即使不使用 webpackChunkName，webpack 5 也会自动在 development 模式下分配有意义的文件名。
  import(/* webpackChunkName: 'math' */ './math.js').then(({ add }) => {
    console.log(add(4, 5))
  })
})
document.body.appendChild(button)
```

**效果：**

点击按钮后才加载 math.bundle.js 并执行了函数打印输出结果

![image-20220803154940332](https://i0.hdslb.com/bfs/album/7a21e36f1c02a1432bd471f022dc03e06f7049c8.png)

第一次加载完页面， math.bundle.js 不会加载，当点击按钮后，才加载 math.bundle.js 文件。

**问题：**

这样做可能**会让用户的交互长时间没有响应的。原因就是待到交互时才进行模块的加载，可能时间会比较长**。由此，我们引入**prefetch**，即预取。

### 9.5 预获取、预加载

Webpack v4.6.0+ 增加了对预获取和预加载的支持。

在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 “resource hint(资源提示)”，来告知浏览器：

- **prefetch(预获取)**：将来某些导航下可能需要的资源（当页面所有内容都加载完毕后，在网络空闲的时候，加载资源）
- **preload(预加载)**：当前导航下可能需要资源

**prefetch**

`src/index.js`

```js
const button = document.createElement('button')
button.textContent = '点击执行加法运算'
button.addEventListener('click', () => {
  // webpackPrefetch: true 在动态引入时开始预获取
  import(/* webpackChunkName: 'math', webpackPrefetch: true */ './math.js').then(({ add }) => {
    console.log(add(4, 5))
  })
})
document.body.appendChild(button)
```

添加第二句魔法注释：`webpackPrefetch: true`

告诉 webpack 执行预获取。这会生成 并追加到页面头部，指示着浏览器在闲置时间预取 math.js 文件。

**效果**
可以看到 math.bundle.js 已经预先获取了

加载完成之后，浏览器又会去自动加载

![image-20220803155257733](https://i0.hdslb.com/bfs/album/44b4b88bc5b564f9883f960fb2cdc21be329b1b1.png)

我们发现，在还没有点击按钮时，` math.bundle.js` 就已经下载下来了。同时，在 app.html 里 webpack 自动添加了一句：

![image-20220803155320537](https://i0.hdslb.com/bfs/album/9d219f4db005b764cca91b05364c4232a1d48199.png)

点击按钮，会立即调用已经下载好的 `math.bundle.js` 文件中的 add 方法：

**preload**

preload 和 prefetch 在用法上相差不大，效果上的差别如下（引自官方文档）：

> - preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。
> - preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。
> - preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。
>   浏览器支持程度不同。

## 10.缓存

以上，我们使用 webpack 来打包我们的模块化后的应用程序，webpack 会生成一个可部署的 `/dist` 目录，然后把打包后的内容放置在此目录中。只要 `/dist` 目录中的内容部署到服务器上，客户端（通常是浏览器）就能够访问网站此服务器的网站及其资源。而最后一步获取资源是比较耗费时间的，这就是为什么浏览器使用一种名为 [缓存](https://searchstorage.techtarget.com/definition/cache) 的技术。可以通过命中缓存，以降低网络流量，使网站加载速度更快，然而，如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。

此指南的重点在于通过必要的配置，以确保 webpack 编译生成的文件能够被客户端缓存，而在文件内容变化后，能够请求到新的文件。

### 10.1 输出文件的文件名

通过使用 `output.filename` 进行[文件名替换](https://www.wenjiangs.com/doc/webpack-configuration/output)，可以确保浏览器获取到修改后的文件。`[hash]` 替换可以用于在文件名中包含一个构建相关(build-specific)的 hash，但是更好的方式是使用 `[chunkhash]` 替换，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。

让我们使用[起步](https://www.wenjiangs.com/doc/webpack-guides-getting-started) 中的示例，以及[管理输出](https://www.wenjiangs.com/doc/webpack-guides-output-management) 中的 `plugins` 来作为项目的基础，所以我们不必手动处理维护 `index.html` 文件：

**project**

```tex
webpack-demo
|- package.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
|- /node_modules
```

`webpack.config.js`

```js
module.exports = {
  //...
  output: {
    filename: 'scripts/[name].[contenthash].js'

    //...
  }

  //...
}
```

**执行打包编译：**

![image-20220803160420311](https://i0.hdslb.com/bfs/album/e88d137948d63254108616d5a75ee4fd9974985e.png)

可以看到，bundle 的名称是它内容（通过 hash）的映射。如果我们不做修改，然后再次运行构建，文件名会保持不变。

### 10.2 缓存第三方库

将第三方库(library)（例如 `lodash` 或 `react`）提取到单独的 `vendor` chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用客户端的长效缓存机制，可以通过命中缓存来消除请求，并减少向服务器获取资源，同时还能保证客户端代码和服务器端代码版本一致。 我们在 optimization.splitChunks 添加如下 `cacheGroups `参数并构建：

```js
module.exports = {
  //...

  optimization: {
    //...

    splitChunks: {
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  }
}
```

**执行编译：**

![image-20220803161022142](https://i0.hdslb.com/bfs/album/9b9197ea811333e9a64c545005df7d1173f6483f.png)

截止目前，我们已经把 JS 文件、样式文件及图片等资源文件分别放到了 `scripts`、`styles`、`images`三个文件夹中。

## 11.js 压缩

安装插件 terser-webpack-plugin

```
pnpm i terser-webpack-plugin -D
```

**配置**

```js
const TerserWebpackPlugin = require("terser-webpack-plugin")

module.exports = {
  ...
  optimization: {
    minimizer: [
      // 使用插件压缩 js 代码 (生产模式)
      new TerserWebpackPlugin({
          parallel: true, //多线程压缩
          extractComments: false //不要注释-因为默认会对每个压缩的文件生成一个txt的注释文本。没必要
        })
    ]
  }
}
```

这个插件，当 mode 是 production 的时候，执行这个配置打包成 js 压缩的形式，而开发环境时，则是打包成原始的 js。
插件的使用文档：https://webpack.docschina.org/plugins/terser-webpack-plugin/
