## 前言

在总结各种跨域问题之前，我们先来了解一下浏览器的同源策略。协议、域名、端口都相同才叫同源。

> 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。
> 设想这样一种情况：A 网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取 A 网站的 Cookie，会发生什么？
> 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。
> 由此可见，"同源政策"是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。

**受到同源限制：**

1）无法读取不同源的 Cookie、LocalStorage 和 IndexDB 。
2）无法获得不同源的 DOM 。
3）不能向不同源的服务器发送 ajax 请求。

**不受同源限制：**
在浏览器中，`<script>`、`<img>`、`<iframe>`、`<link>`等标签都可以跨域加载资源，而不受同源策略的限制。

**浏览器对跨域访问的判定：**
CORS 机制把跨域请求分为两类：简单请求和非简单请求。

> 1.  请求方法是以下三种方法之一：HEAD、GET、POST
>     2）HTTP 的头信息不超出以下几种字段：
>     Accept
>     Accept-Language
>     Content-Language
>     Last-Event-ID
>     Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain
>     凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。

**简单请求：**浏览器会带上 Origin 的请求头发送到服务器，服务器根据 Origin 判断是否许可。如果许可就会带上 CORS 相关响应头，如果不在许可范围内就不会带上 CORS 相关的响应头。浏览器再根据响应头中是否有相关的 CORS 响应头，来判断拦截响应 body 和抛出错误。

**非简单请求：**非简单请求会在发真正的请求之前发送一个 OPTIONS 的带着 Origin、Access-Control-Request-Method、Access-Control-Request-Headers 等 CORS 相关的请求头的预检请求到服务器，服务器确认可以这样请求，就会返回带着 Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers 等 CORS 相关的响应头的响应，浏览器检查到相关的 CORS 响应头，说明通过预检可以继续发送真正的请求；服务器确认不可以，则不会返回这些相关响应头，浏览器没检查到 CORS 的响应头就会抛出错误。

## 一、代理跨域

**场景 1：**你的项目 myweb，myweb 的前端有一个接口是去访问一个非 myweb 的服务器。非 myweb 服务器是第三方服务器，你不能去对第三方服务器做改动。

**场景 2：**你的项目是个微服务架构的。那你的前端页面可能就需要去很多个服务器上访问数据。

**原理解析：**
跨域请求报错归根结底是浏览器禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。如果是服务器跨域向多个不同的服务器发送请求就不会有跨域问题存在。因此，我们可以让浏览器只向一个服务器方式请求，让这个服务器代替浏览器去不同的服务器上请求资源再返回给浏览器。这个服务器就是代理服务器了。

下面推荐一个常用代理服务器 nginx。

**什么是 nginx?**
Nginx (engine x) 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。

把 ui 所在的服务器和跨域服务器都用 nginx 代理转发，浏览器访问 nginx，nginx 到 ui 服务获取 ui，再把 ui 下载到浏览器，浏览器发起 ui 中的 URL，该 URL 为 Nginx 封装后的跨域服务器的 URL 或 ui 服务器的 URL，该 URL 到达 Nginx 之后，会被转发到跨域服务器或 ui 服务器，请求处理完毕后，会通过 Nginx 中转返回给浏览器。暴露出来的或者浏览器所发起的 url 都是 nginx 的 url，nginx 去跨域服务器和 ui 服务器获取响应，返给浏览器，这样就没有跨域问题了。

## 二、CORS

**场景：**
前后端分离的开发模式下，在本地进行接口联调时：也许在你的项目里，你想尝试前后端分离的开发模式。

你在本地开发时，mock 了一些假数据来帮助自己本地开发。而有一天，你希望在本地和后端同学进行联调。此时，后端 rd 的接口地址和你发生了跨域问题。这阻止了你们的联调，你只能继续使用你 mock 的假数据。

**解决方案：**
CORS 需要浏览器和服务器同时支持。如何支持？请看**浏览器对跨域访问的判定**小节。

整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。

服务器要给接口的响应头设置：Access-Control-Allow-Origin：＊

## 三、jsonp

**场景：跨域发送 get 请求**

jsonp 解决跨域问题的本质：`<script>`标签可以请求不同域名下的资源，即`<script>`请求不受浏览器同源策略影响。
首先给 body 动态添加一个` <script>`

```javascript
var script = document.createElement('script')
script.setAttribute('type', 'text/javascript')
script.src = 'http://example.com/ip?callback=foo'
document.body.appendChild(script)
function foo(data) {
  console.log('Your public IP address is: ' + data.ip)
}
```

上面的 script 会向`http://example.com/`服务器发送请求，这个请求的 url 后面带了个 callback 参数，是用来告诉服务器回调方法的方法名的。因为服务器收到请求后，会把相应数据写进 foo 的参数位置，也就是说服务器会返回的脚本如下

```javascript
foo({ ip: '8.8.8.8' })
```

这样浏览器通过`<script>`下载的资源就是上面的脚本了，`<script>`下载完成就会立即执行，也就是说`http://example.com/ip?callback=foo`这个请求返回后就会立即执行上面的脚本代码，而这个脚本代码就是调用回调方法和拿到 json 数据了。

## 四、document.domain 跨域

**场景 1：**你的`http://www.damonare.cn/a.html`页面里使用`<iframe>`调用另一个`http://damonare.cn/b.html`页面。这时候你想在 a 页面里获取 b 页面里的 dom，然后进行操作。然后你会发现你不能获得 b 的 dom。`document.getElementById("myIFrame").contentWindow.document`或`window.parent.document.body`因为两个窗口不同源而报错。

**解决方案：**这时候你只需要在 a 页面里和 b 页面里把`document.domain`设置成相同的值就可以在两个页面里操作 Dom 了。

**场景 2：**你在`http://www.damonare.cn/a.html`页面里写入了`document.cookie = "test1=hello";`你在`http://damonare.cn/b.html`页面是拿不到这个 cookie 的。

**解决方案：**Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置 document.domain 共享 Cookie。另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名。这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。

**注意：
**`document.domain`限制：虽然可读写，但只能设置成自身或者是高一级的父域且主域必须相同。所以只能解决一级域名相同二级域名不同的跨域问题。
`document.domain`只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法跨域。

## 五、window.name 跨域

**场景 1：**现在浏览器的一个标签页里打开`http://www.damonare.cn/a.html`页面，你通过 location.href=`http://baidu.com/b.html`，在同一个浏览器标签页里打开了不同域名下的页面。这时候这两个页面你可以使用`window.name`来传递参数。因为`window.name`指的是浏览器窗口的名字，只要浏览器窗口相同，那么无论在哪个网页里访问值都是一样的。

**场景 2：**你的`http://www.damonare.cn/a.html`页面里使用`<iframe>`调用另一个`http://baidu.com/b.html`页面。这时候你想在 a 页面里获取 b 页面里的 dom，然后进行操作。然后你会发现你不能获得 b 的 dom。同样会因为不同源而报错，和上面提到的不同之处就是两个页面的一级域名也不相同。这时候`document.domain`就解决不了了。

**解决方案：**浏览器窗口有`window.name`属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。。比如你在 b 页面里设定`window.name="hello"`，你再返回到 a 页面，在 a 页面里访问`window.name`，可以得到`hello`。

这种方法的优点是，window.name 容量很大，可以放置非常长的字符串；缺点是必须监听子窗口 window.name 属性的变化，影响网页性能。

## 六、postMessage 方法跨域

**场景 1:**在 a 页面里打开了另一个不同源的页面 b，你想要让 a 和 b 两个页面互相通信。比如，a 要访问 b 的 LocalStorage。

**场景 2:**你的 a 页面里的`iframe`的 src 是不同源的 b 页面，你想要让 a 和 b 两个页面互相通信。比如，a 要访问 b 的 LocalStorage。

**解决方案：**HTML5y 引入了一个全新的 API，跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个`window.postMessage`方法，允许跨窗口通信，不论这两个窗口是否同源。a 就可以把它的 LocalStorage，发送给 b，b 也可以把自己的 LocalStorage 发给 a。

window.postMessage(message, targetOrigin, [transfer])，有三个参数：

> **message**是向目标窗口发送的数据；
> **targetOrigin**属性来指定哪些窗口能接收到消息事件，其值可以是字符串"\*"（表示无限制）或者一个 URI（或者说是发送消息的目标域名）；
> **transfer**可选参数，是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

另外消息的**接收方必须有监听事件**，否则发送消息时就会报错。`The target origin provided ('http://localhost:8080') does not match the recipient window's origin ('http://localhost:63343').`

`window.addEventListener("message",onmessage);`onmessage 接收到的 message 事件包含三个属性：

> **data：**从其他 window 中传递过来的数据。
> **origin：**调用 postMessage 时消息发送方窗口的 origin 。请注意，这个 origin 不能保证是该窗口的当前或未来 origin，因为 postMessage 被调用后可能被导航到不同的位置。
> **source：**对发送消息的窗口对象的引用; 您可以使用此来在具有不同 origin 的两个窗口之间建立双向通信。

例子：我在 a 页面执行

```javascript
var popup = window.open('http://localhost:3000', 'title')
popup.postMessage('Hello World!', 'http://localhost:3000')
```

同时在`http://localhost:3000`的页面里监听 message 事件：

```javascript
window.onload = function () {
  window.addEventListener('message', onmessage)
}
function onmessage(event) {
  if (event.origin === 'http://localhost:63343') {
    // http://localhost:63343是发送方a的域名
    console.log(event.data) // 'Hello World!'
  }
  console.log(event.data) // 'Hello World!'
}
```

> 注意: 在 Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3)之前， 参数 message 必须是一个字符串。 从 Gecko 6.0 (Firefox 6.0 / Thunderbird 6.0 / SeaMonkey 2.3)开始，参数 message 被使用结构化克隆算法进行序列化。这意味着您可以将各种各样的数据对象安全地传递到目标窗口，而不必自己序列化它们。

## 七、location.hash 跨域

location.hash 就是指 URL 的#号后面的部分。
**场景：**
父窗口和 iframe 的子窗口之间通讯或者是 window.open 打开的子窗口之间的通讯。

**解决方案：**
父窗口改变子窗口的 url 的#号后面的部分，后者把要传递的参数写在#后面，子窗口监听 window.onhashchange 事件，得到通知，读取 window.location.hash 解析出有用的数据。同样子窗口也可以向父窗口传递数据。
