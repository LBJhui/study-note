# 循环遍历数组方式总结

- `for` 循环：

```javascript
for (let index = 0; index < someArray.length; index++) {
  const elem = someArray[index]
  // ···
}
```

- `for-in` 循环：

```javascript
for (const key in someArray) {
  console.log(key)
}
```

- 数组方法 `.forEach()`：

```javascript
someArray.forEach((elem, index) => {
  console.log(elem, index)
})
```

- `for-of` 循环：

```javascript
for (const elem of someArray) {
  console.log(elem)
}
```

`for-of` 通常是最佳选择。我们会明白原因。

## `for`**循环 [ES1]**

JavaScript 中的 `for` 循环很古老，它在 ECMAScript 1 中就已经存在了。`for` 循环记录 `arr` 每个元素的索引和值：

```javascript
const arr = ['a', 'b', 'c']
arr.prop = 'property value'

for (let index = 0; index < arr.length; index++) {
  const elem = arr[index]
  console.log(index, elem)
}

// Output:
// 0, 'a'
// 1, 'b'
// 2, 'c'
```

`for` 循环的优缺点是什么？

- 它用途广泛，但是当我们要遍历数组时也很麻烦。
- 如果我们不想从第一个数组元素开始循环时它仍然很有用，用其他的循环机制很难做到这一点。

## `for-in`循环 [ES1]

`for-in` 循环与 `for` 循环一样古老，同样在 ECMAScript 1 中就存在了。下面的代码用 `for-in` 循环输出 arr 的 key：

```javascript
const arr = ['a', 'b', 'c']
arr.prop = 'property value'

for (const key in arr) {
  console.log(key)
}

// Output:
// '0'
// '1'
// '2'
// 'prop'
```

`for-in` 不是循环遍历数组的好方法：

- 它访问的是属性键，而不是值。
- 作为属性键，数组元素的索引是字符串，而不是数字。
- 它访问的是所有可枚举的属性键（自己的和继承的），而不仅仅是 Array 元素的那些。

`for-in` 访问继承属性的实际用途是：遍历对象的所有可枚举属性。

## 数组方法`.forEach()`[ES5]

鉴于 `for` 和 `for-in` 都不特别适合在数组上循环，因此在 ECMAScript 5 中引入了一个辅助方法：`Array.prototype.forEach()`：

```javascript
const arr = ['a', 'b', 'c']
arr.prop = 'property value'

arr.forEach((elem, index) => {
  console.log(elem, index)
})

// Output:
// 'a', 0
// 'b', 1
// 'c', 2
```

这种方法确实很方便：它使我们无需执行大量操作就能够可访问数组元素和索引。如果用箭头函数（在 ES6 中引入）的话，在语法上会更加优雅。

`.forEach()` 的主要缺点是：

- 不能在它的循环体中使用 `await`。
- 不能提前退出 `.forEach()` 循环。而在 `for` 循环中可以使用 `break`。

### 中止 `.forEach()` 的解决方法

如果想要中止 `.forEach()` 之类的循环，有一种解决方法：`.some()` 还会循环遍历所有数组元素，并在其回调返回真值时停止。

```javascript
const arr = ['red', 'green', 'blue']
arr.some((elem, index) => {
  if (index >= 2) {
    return true // 中止循环
  }
  console.log(elem)
  //此回调隐式返回 `undefined`，这
  //是一个伪值。 因此，循环继续。
})

// Output:
// 'red'
// 'green'
```

可以说这是对 `.some()` 的滥用，与 `for-of` 和 `break` 比起来，要理解这段代码并不容易。

## `for-of`循环 [ES6]

`for-of` 循环在 ECMAScript 6 开始支持：

```javascript
const arr = ['a', 'b', 'c']
arr.prop = 'property value'

for (const elem of arr) {
  console.log(elem)
}
// Output:
// 'a'
// 'b'
// 'c'
```

`for-of` 在循环遍历数组时非常有效：

- 用来遍历数组元素。

- 可以使用 `await`

- - 如果有需要，可以轻松地迁移到 `for-await-of`。

- 甚至可以将 `break` 和 `continue` 用于外部作用域。

### `for-of` 和可迭代对象

`for-of` 不仅可以遍历数组，还可以遍历可迭代对象，例如遍历 Map：

```javascript
const myMap = new Map().set(false, 'no').set(true, 'yes')
for (const [key, value] of myMap) {
  console.log(key, value)
}

// Output:
// false, 'no'
// true, 'yes'
```

遍历 `myMap` 会生成 [键，值] 对，可以通过对其进行解构来直接访问每一对数据。

### `for-of` 和数组索引

数组方法 `.entries()` 返回一个可迭代的 `[index，value]` 对。如果使用 `for-of` 并使用此方法进行解构，可以很方便地访问数组索引：

```javascript
const arr = ['chocolate', 'vanilla', 'strawberry']

for (const [index, elem] of arr.entries()) {
  console.log(index, elem)
}
// Output:
// 0, 'chocolate'
// 1, 'vanilla'
// 2, 'strawberry'
```

## 总结

`for-of` 循环的的可用性比 `for`，`for-in` 和 `.forEach()` 更好。

通常四种循环机制之间的性能差异应该是无关紧要。如果你要做一些运算量很大的事，还是切换到 WebAssembly 更好一些。



# array.sort()

## 1.`array.sort()`不带参数

`array.sort()` 是数组实例上的一个方法，用于对数组进行适当的排序（在原始数组上原地操作）并返回排序后的数组。

当不带参数调用时，数组元素项会被转换为字符串并按字母序进行排序。

例如对下面的数组进行排序：

```javascript
const names = ['joker', 'batman', 'catwoman'];
names.sort(); // => ['batman', 'catwoman', 'joker']
```

会按照按字母顺序排序：`['batman'，'catwoman'，'joker']`。

但是，对数字调用该方法也会按照字母序进行排序：

```javascript
const numbers = [10, 5, 11];

numbers.sort(); // => [10, 11, 5]
```

## 2. 带比较器的  `array.sort()`

不过 `array.sort()` 方法有一个可选参数：比较器函数。

```javascript
const mutatedArray = array.sort([comparator]);
```

用这个函数可以控制排序过程中元素在数组中的排序方式。

如果 `comparator(a，b)` 的返回值为：

- 负数 `<0`：那么 `a` 会被放在 `b` 之前
- 正数“> 0”：那么 `b` 会被放置在 `a` 之前
- `0`：则比较元素的位置不变

为了正确地对数字按升序进行排序，应该用下面的比较器函数：

```javascript
const numbers = [10, 5, 11];

numbers.sort((a, b) => {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}); // => [5, 10, 11]
```

这样就可以正确地对数字进行排序了：`[5, 10, 11]`。

在升序排列的数组中，较小的数字位于较大的数字之前。这是在编写比较器函数时需要维护的属性：

- 如果 `a < b`：函数返回 `-1`，将 `a` 放在 `b` 的前面（例如 `5 <8`，因此 `5` 在 `8` 之前）
- 如果 `a> b`：函数返回 `1`，将 `b` 放在 `a` 之前（例如 `10> 3`，因此 `3` 在 `10` 的前面）
- 如果 `a === b`：顺序不变。

前面例子中的比较器函数有些长。我们可以这样简化：

```javascript
const numbers = [10, 5, 11];
numbers.sort((a, b) => a - b); // => [5, 10, 11]
```

## 3. 对类型化数组排序

JavaScript 中的类型化数组包含特定类型的元素，例如 `UInt8`：8位无符号整数，`Float64`：64位浮点数等。而普通数组中的元素可以是任何类型，甚至可以是多种类型。

类型化数组的好处是，默认情况下它们的 `sort()` 方法对数字按升序进行排序。

如果不用比较器函数，那么利用类型化数组是对数字进行排序的好办法：

```javascript
const numbers = [10, 5, 11];

const sortedNumbers = [...new Float64Array(numbers).sort()];

sortedNumbers; // => [5, 10, 11]
```

`new Float64Array(numbers)` 创建一个类型化数组的实例并初始化。

`new Float64Array(numbers).sort()` 按升序排序类型数组。在这里不需要比较器函数。

最后，展开运算符 `[...new Float64Array(numbers).sort()]` 把类型数组中的排序数字提取到常规数组中。

## 总结

如果不带参数调用 `array.sort()` 方法，将会按字母序对元素进行排序。所以不应该简单的用 `array.sort()` 对数字进行升序排序。

但是你可以指定一个比较器函数 `array.sort(comparator)` 来定制元素的排序方式。建议使用 `numbers.sort((a, b) => a - b)` 这种最简洁的方式对数字数组进行排序。