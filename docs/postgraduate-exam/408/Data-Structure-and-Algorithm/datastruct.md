# 线性表

## 顺序表

### 1.初始化

初始化是指为顺序表分配一段预定义大小的连续空间，用 elem 记录这段空间的基地址，当前空间内没有任何数据元素，因此元素的实际个数为 0。假设我们已经预定义了一个最大空间数 Maxsize，那么就用 new 分配大小为 Maxsize 的空间，分配成功会返回空间的首地址，分配失败会返回空指针。

```c
bool InitList(SqList &L)        //构造一个空的顺序表L
{ //L前面加&表示引用参数，函数内部的改变跳出函数后仍然有效
  //如果不加&，函数内部的改变在跳出函数后便会无效
  L.elem = new int[Maxsize0];   //为顺序表动态分配Maxsize个空间
  if(! L.elem) return false;    //分配空间失败
  L.length=0;
  return true;                  //顺序表长度为0
}
```

### 2.创建

顺序表创建是向顺序表中输入数据，输入数据的类型必须与类型定义中的类型一致。

算法步骤
1）初始化下标变量 i=0，判断顺序表是否已满，如果是则结束；否则执行第 2 步。
2）输入一个数据元素 x。
3）将数据 x 存入顺序表的第 i 个位置，即 L.elem[i]=x，然后 i++。
4）顺序表长度加 1，即 L.length++。
5）直到数据输入完毕。

```c
bool CreateList(SqList &L)    //创建一个顺序表L
{
  //L加&表示引用类型参数，函数内部的改变跳出函数仍然有效
  //不加&则在内部改变时，跳出函数后无效
  int x, i=0;
  cin >> x;
  while(x != -1)      	//输入-1时结束，也可以设置其他的结束条件
  {
    if(L.length==Maxsize)
    {
      count<<"顺序表已满!"
      return false;
    }
    cin>>x;         	//输入一个数据元素
    L.elem[i++]=x;  	//将数据存入第i个位置，然后i++
    L.length++;       	//顺序表长度加1
    cin>>x;         	//输入一个数据元素
  }
  return true;
}
```

### 3.取值

顺序表中的任何一个元素都可以立即找到，称为随机存取方式。

注意：位序是指第几个元素，位序和下标差 1。

```c
bool GetElem(SqList L, int i, int &e)
{
  if(i<1 || i>L.length) return false;
    //判断i值是否合理，若不合理，则返回false
  e=L.elem[i-1];    //第i-1个单元存储着第i个数据
  return true;
}
```

### 4.查找

在顺序表中查找一个元素 e，可以从第一个元素开始顺序查找，依次比较每一个元素值。如果相等，则返回元素位置（位序，即第几个元素）；如果查找整个顺序表都没找到，则返回-1。

```c
int LocateElem(SqList L, int e)
{
  for(i=0; i<L.length; i++)
    if(L.elem[i-1]==e) return i + 1;    //下标为i，实际为第i+1个元素
  return -1;      						//如果没找到，则返回-1
}
```

### 5.插入

在顺序表中第 i 个位置之前插入一个元素 e，需要从最后一个元素开始，后移一位……直到把第 i 个元素也后移一位，然后把 e 放入第 i 个位置。

算法步骤
1）判断插入位置 i 是否合法（1≤i≤L.length+1），可以在第一个元素之前插入，也可以在第 L.length+1 个元素之前插入。
2）判断顺序表的存储空间是否已满。
3）将第 L.length 至第 i 个元素依次向后移动一个位置，空出第 i 个位置。
4）将要插入的新元素 e 放入第 i 个位置。
5）表长加 1，插入成功返回 true。

```c
bool ListInsert_Sq(SqList &L, int i, int e)
{
    if(i<1 || i>L.length+1) return false; 	//i值不合法
    if(L.length==Maxsize) return false;		//存储空间已满
    for(int j=L.length-1; j>i-1; j--)
        L.elem[j+1]=L.elem[j]				//从最后一个元素开始后移，直到第i个元素后移
    L.elem[i-1]=e;							//将新元素放入第i个位置
    L.length++;								//表长加1
    return true
}
```

### 6.删除

在顺序表中删除第 i 个元素，需要把该元素暂存到变量 e 中，然后从 i+1 个元素开始前移……直到把第 n 个元素也前移一位，即可完成删除操作。

算法步骤

1）判断删除位置 i 是否合法（1≤i≤L.length）。
2）将欲删除的元素保存在 e 中。
3）将第 i+1 至第 n 个元素依次向前移动一个位置。
4）表长减 1，删除成功，返回 true。

```c
bool ListDelete_Sq(SqList &L, int i, int &e)
{
    if(i<1 || i>L.length) return false; //i值不合法
    e=L.elem[i-1];						//将欲删除的元素保存在e中
    for(int j=i; j<=L.length-1; j++)
        L.elem[j-1]=L.elem[j];			//被删除元素之后的元素前移
    L.length--;							//表长减1
    return true;
}
```

**顺序表的优点**：操作简单，存储密度高，可以随机存取，只需要 O(1)的时间就可以取出第 i 个元素。

**顺序表的缺点**：需要预先分配最大空间，最大空间数估计过大或过小会造成空间浪费或溢出。插入和删除操作需要移动大量元素。

## 单链表

链表是线性表的链式存储方式。逻辑上相邻的数据在计算机内的存储位置不一定相邻。

### 单链表的存储方式

可以给每个元素附加一个指针域，指向下一个元素的存储位置。

每个节点包含两个域：数据域和指针域。数据域存储数据元素，指针域存储下一个节点的地址，因此指针指向的类型也是节点类型。每个指针都指向下一个节点，都是朝一个方向的，这样的链表称为单向链表或单链表。

在顺序表中，想找第 i 个元素，可以立即通过 L.elem[i-1]找到，想找哪个就找哪个，称为**随机存取**。但是在单链表中，想找第 i 个元素就没那么容易，必须从头开始，按顺序一个一个找，一直数到第 i 个元素，称为**顺序存取**。

### 单链表的基本操作

#### 1.初始化

单链表的初始化是指构建一个空表。先创建一个头节点，不存储数据，然后令其指针域为空。

```c
bool InitList_L(LinkList &L)	//构造一个空的单链表
{
    L=new LNode; 				//生成新节点作为头节点，用头指针L指向头节点
    if(! L)
        return false; 			//生成节点失败
    L->next=NULL;				//头节点的指针域置空
    return true;
}
```

#### 2.创建

创建单链表分为**头插法**和**尾插法**两种，头插法是指每次把新节点插到头节点之后，其创建的单链表和数据输入顺序正好相反，因此也称为逆序建表。尾插法是指每次把新节点链接到链表的尾部，其创建的单链表和数据输入顺序一致，因此也称为正序建表。

头插法每次把新节点插入到头节点之后，创建的单链表和数据输入顺序相反。

```c
void CreateList_H(LinkList &L)//头插法创建单链表
{
    int n;							//输入n个元素的值，建立到头节点的单链表L
    LinkList s;						//定义一个指针变量
    L=new LNode;
    L->next=NULL;					//先建立一个带头节点的空链表
    cout<<"请输入元素个数n:"<<endl;
    cin>>n;
    cout<<"请依次输入n个元素:"<<endl;
    cout<<"头插法创建单链表..."<<endl;
    while(n--)
    {
        s=new LNode;				//生成新节点
        cin>>s->data;				//输入元素赋值给新节点的数据域
        s->next=L->next;
        L->next=s;					//将新节点s插入头节点之后
    }
}
```

尾插法每次把新节点链接到链表的尾部，其创建的单链表和数据输入顺序一致。

尾插法每次把新节点链接到链表的尾部，因此需要一个尾指针永远指向链表的尾节点。

```c
void CreateList_R(LinkList &L)//尾插法创建单链表
{
    //输入n个元素的值，建立带表头节点的单链表L
    int n;
    LinkList s, r;
    L=new LNode;
    L->next=NULL;						//先建立一个带头节点的空链表
    r=L;								//尾指针r指向头节点
    cout<<"请输入元素个数n:"<<endl;
    cin>>n;
    cout<<"请依次输入n个元素:"<<endl;
    cout<<"尾插法创建单链表..."<<endl;
    while(n--)
    {
        s=new LNode;					//生成新节点
        cin>>s->data;					//输入元素值赋给新节点的数据域
        s->next=NULL;
        r->next=s;						//将新节点s插入尾结点r之后
        r=s;							//r指向新的尾结点s
    }
}
```

#### 3.插值

单链表的取值不像顺序表那样可以随机访问任何一个元素，单链表只有头指针，各个节点的物理地址是不连续的。要想找到第 i 个节点，就必须从第一个节点开始按顺序向后找，一直找到第 i 个节点。

注意：链表的头指针不可以随意改动！

算法步骤
1）先定义一个 p 指针，指向第一个元素节点，用 j 作为计数器，j=1。
2）如果 p 不为空且 j<i，则 p 指向 p 的下一个节点，然后 j 加 1，即：p=p->next;j++。
3）直到 p 为空或者 j=i 停止。p 为空，说明没有数到 i，链表就结束了，即不存在第 i 个节点；j=i，说明找到了第 i 个节点。

```c
bool GetElem_L(LinkList L, int i, int &e)//单链表的取值
{
    //在带头节点的单链表L中查找第i个元素
    //用e记录L中第i个数据元素的值
    int j;
    LinkList p;
    p=L->next;					//p指向第一个数据节点
    j=1;						//j为计数器
    while(j<i&&p)				//顺着链表向后扫描，直到p指向第i个元素或p为空
    {
        p=p->next;				//p指向下一个节点
        j++;					//计数器加1
    }
    if(!p||j>i)					//i值不合法，i>n或i<=0
        return false;
    e=p->data;					//取第i个节点的数据域
    return true;
}
```

#### 4.查找

在一个单链表中查找是否存在元素 e，可以定义一个 p 指针，指向第一个元素节点，比较 p 指向节点的数据域是否等于 e。如果相等，查找成功，返回 true；如果不等，则 p 指向 p 的下一个节点，继续比较，如果 p 为空，查找失败，返回 false。

```c
bool LocateElem_L(LinkList L, int e)//在带头节点的单链表L中查找值为e的元素
{
    LinkList p;
    p=L->next;
    while(p&&p->data!=e)			//沿着链表向后扫描，直到p为空或p所指节点数据域等于e
        p=p->next;					//p指向下一个节点
    if(!p)
        return false;				//查找失败，p为NULL
    return true;
}
```

#### 5.插入

如果要在第 i 个节点之前插入一个元素，则必须先找到第 i-1 个节点。

单链表只有一个指针域，是向后操作的，不可以向前操作。如果直接找到第 i 个节点，就无法向前操作，把新节点插入第 i 个节点之前。实际上，在第 i 个节点之前插入一个元素相当于在第 i-1 个节点之后插入一个元素，因此先找到第 i-1 个节点，然后将新节点插在其后面即可。

算法步骤
1）定义一个 p 指针，指向头节点，用 j 作为计数器，j=0。
2）如果 p 不为空且 j<i-1，则 p 指向 p 的下一个节点，然后 j 加 1，即：p=p->next;j++。
3）直到 p 为空或 j >=i-1 停止。
4）p 为空，说明没有数到 i-1，链表就结束了，即 i ＞ n+1, i 值不合法；j >i-1 说明 i ＜ 1，此时 i 值不合法，返回 false。如果 j=i-1，说明找到了第 i-1 个节点。
5）将新节点插到第 i-1 个节点之后。

```c
bool ListInser_L(LinkList &L, int i, int e)	//单链表的插入
{
    int j;
    LinkList p, s;
    p=L;
    j=0;
    while(p&&j<i-1)							//查找第i-1个节点，p指向该节点
    {
        p=p->next;
        j++;
    }
    if(!p||j>i+1)							//i>n+1或者i<1
        return false;
    s=new LNode;							//生成新节点
    s->data=e;								//将数据元素e放入新节点的数据域
    s->next=p->next;						//将新节点的指针域指向第i个节点
    p->next=s;								//将节点p的指针域指向节点s
    return true;
}
```

#### 6.删除

删除一个节点，实际上是把这个节点跳过去。根据单向链表向后操作的特性，要想跳过第 i 个节点，就必须先找到第 i-1 个节点，否则是无法跳过去的。

```c
bool ListDelete_L(LinkList &L, int i)//单链表的删除
{
    //在带头节点的单链表中，删除第i个位置
    LinkList p, q;
    int j;
    p=L;
    j=0;
    while((p->next)&&(j<i-1))				//查找第i-1个节点，p指向该节点
    {
        p=p->next;
        j++;
    }
    if(!(p->next)||(j>i-1))					//当i>n或i<1时，删除位置不合理
        return false;
    q=p->next;								//临时保存被删除节点的地址以备释放空间
    p->next=q->next;						//将q节点的下一个节点地址赋值给p节点的指针域
    delete q;								//释放被删除节点的空间
    return true;
}
```

## 双向链表

### 双向链表的存储方式

单链表只能向后操作，不可以向前操作。为了向前、向后操作方便，可以给每个元素附加两个指针域，一个存储前一个元素的地址，另一个存储下一个元素的地址。这种链表称为双向链表。

### 双向链表的基本操作

下面以带头节点的双向链表为例，讲解双向链表的初始化、创建、取值、查找、插入、删除操作。

#### 1.初始化

双向链表初始化是指构建一个空表。先创建一个头节点，不存储数据，然后令其前后两个指针域均为空。

```c
bool InitList_L(DuLinkList &L)			//构造一个空的双向链表
{
    L=new DuLNode;						//生成新节点作为头节点，用头指针L指向头节点
    if(!L)
        return false;					//生成节点失败
    L->prior=L->next=NULL;				//头节点的两个指针域置空
    return true;
}
```

#### 2.创建

创建双向链表也可以用头插法和尾插法。头插法创建的链表和输入顺序正好相反，称为逆序建表；尾插法创建的链表和输入顺序一致，称为正序建表。

```c
void CreateDuList_H()				//头插法创建双向链表
{
    //输入n个元素的值，建立到头节点的单链表L
    int n;
    DuLinkList s;					//定义一个指针变量
    L=new DuLNode;
    L->prior=L->next=NULL;			//先建立一个带头节点的空链表
    cout<<"请输入元素个数n:"<<endl;
    cin>>n;
    cout<<"请依次输入n个元素:"<<endl;
    count<<"头插法创建单链表..."<<endl;
    while(n--)
    {
        s=new DuLNode;				//生成新节点s
        cin>>s->data;				//输入元素值赋值给新节点的数据域
        if(L->next)					//如果L后面有节点，则修改其后面节点的prior指针
            //否则只修改后面3个指针即可
            L->next->prior=s;
        s->next=L->next;
        s->prior=L;
        L-next=s;					//将新节点s插入头节点之后
    }
}
```

尾插法建双向链表和尾插法建单链表类似，需要有一个尾指针，不再赘述。

#### 3.取值和查找

双向链表的取值、查找和单链表的一样，此处不再赘述。

#### 4.插入

单链表只有一个指针域，是向后操作的，不可以向前处理，因此单链表如果在第 i 个节点之前插入一个元素，就必须先找到第 i-1 个节点。在第 i 个节点之前插入一个元素相当于把新节点放在第 i-1 个节点之后。而双向链表不需要，因为有两个指针，可以向前后两个方向操作，直接找到第 i 个节点，就可以把新节点插入第 i 个节点之前。注意：这里假设第 i 个节点是存在的，如果第 i 个节点不存在，而第 i-1 个节点存在，还是需要找到第 i-1 个节点，将新节点插入第 i-1 个节点之后。

修改指针顺序的原则：**先修改没有指针标记的那一端**。

```c++
bool ListInsert_L(DuLinkList &L, int i, int &e)		//双向链表的插入
{
    //在带头节点的单链表中第i个位置之前插入值为e的新节点
    int j;
    DuLinkList p, s;
    p=L;
    j=0;
    while(p&&j<i)									//查找第i个节点，p指向该节点
    {
        p=p->next;
        j++;
    }
    if(!p||j>i)										//i>n+1或者i<1
        return false;
    s=new DuLNode;									//生成新节点
    s->data=e;										//将新节点的数据域置为e
    p->prior->next=s;
    s->prior=p->prior;
    s->next=p;
    p->prior=s;
    return true;
}
```

#### 5.删除

删除一个节点，实际上是把这个节点跳过去。在单向链表中，必须先找到第 i-1 个节点，才能把第 i 个节点跳过去。双向链表不必如此，只要直接找到第 i 个节点，然后修改指针即可。

```c++
bool ListDelete_L(DuLinkList &L, int i)				//双向链表的删除
{
    //在带头节点的双向链表中，删除第i个节点
    DuLinkList p;
    int j;
    p=L;
    j=0;
    while(p&&(j<i))									//查找第i个节点，p指向该节点
    {
        p=p->next;
        j++;
    }
    if(!p||(j>i))									//当i>n或i<1时，删除位置不合理
        return false;
    if(p->next)										//如果p的后继节点存在
        p->next->prior=p->prior;
    p->prior->next=p->next;
    delete p;										//释放被删除节点的空间
    return true;
}
```

## 循环链表

单链表中，只能向后，不能向前。如果从当前节点开始，无法访问该节点前面的节点，而最后一个节点的指针指向头节点，形成一个环，就可以从任何一个节点出发，访问所有的节点，这就是循环链表。循环链表和普通链表的区别就是最后一个节点的后继指向了头节点。

单向循环链表最后一个节点的 next 域不为空，而是指向了头节点。

双向循环链表除了让最后一个节点的后继指向第一个节点外，还要让头节点的前驱指向最后一个节点。

双向循环链表为空表时，`L->next=L->prior=L`。

链表的优点：链表是动态存储，不需要预先分配最大空间；插入删除不需要移动元素。

链表的缺点：每次动态分配一个节点，每个节点的地址是不连续的，需要有指针域记录下一个节点的地址，指针域需要占用一个 int 的空间，因此存储密度低（数据所占空间/节点所占总空间）。存取元素必须从头到尾按顺序查找，属于顺序存取。

## 线性表的应用

### 合并有序顺序表

题目：将两个有序（非递减）顺序表 La 和 Lb 合并为一个新的有序（非递减）顺序表。

解题思路

1）首先创建一个顺序表 Lc，其长度为 La 和 Lb 的长度之和。
2）然后从 La 和 Lb 中分别取数，比较其大小，将较小者放入 Lc 中，一直进行下去，直到其中一个顺序表 La 或 Lb 中的数取完为止。
3）把未取完的数再依次取出放入 Lc 中即可。

```c++
void MergeSqlist(SqList La, SqList Lb, SqList &Lc)		//有序顺序表的合并
{
    //已知有序顺序表La和Lb的元素按值非递减排列
    //La和Lb合并得到新的有序顺序表Lc，Lc的元素也按值非递减排列
    int i, j, k;
    i=j=k=0;
    Lc.length=La.length+Lb.length;						//新表长度为待合并两表的长度之和
    Lc.elem=new int[Lc.length];							//为合并后的新表分配一段空间
    while(i<La.length&&j<Lb.length)						//两个表都非空
    {
        if(La.elem[i]<=Lb.elem[j])						//依次取出两表中较小值放入Lc表中
            Lc.elem[k++]=La.elem[i++];
        else
            Lc.elem[k++]=Lb.elem[j++];
    }
    while(i<La.length)									//La有剩余，依次将La的剩余元素放入Lc表的尾部
        Lc.elem[k++]=La.elem[i++];
    while(j<Lb.length)									//Lb有剩余，依次将Lb的剩余元素放入Lc表的尾部
        Lc.elem[k++]=Lb.elem[j++];
}
```

算法复杂度分析

合并操作需要将 La 和 Lb 中的每一个元素取出放入 Lc 中，如果 La 和 Lb 的长度分别为 m、n，那么合并操作时间复杂度为 O(m+n)，空间复杂度也为 O(m+n)。

### 合并有序链表

题目：将两个有序（非递减）单链表 La 和 Lb 合并为一个新的有序（非递减）单链表。

解题思路

链表合并不需要再创建空间，只需要“穿针引线”，把两个单链表中的节点按非递减的顺序串联起来即可。

注意：单链表的头指针不可以移动，一旦头指针丢失，就找不到该单链表了，因此需要辅助指针。

```c++
void MergeLinkList(LinkList La, LinkList Lb, LinkList &Lc)
{
    LinkList p, q, r;
    p=La->next;							//p指向La的第一个数据元素节点
    q=Lb->next;							//q指向Lb的第一个数据元素节点
    Lc=La;								//Lc指向La的头节点
    r=Lc;								//r指向新链表Lc的尾部
    while(p&&q)
    {
        if(p->data<=q->data)			//把p指向的节点串起来
        {
            r->next=p;
            r=p;
            p=p->next;
        }
        else							//把q指向的节点串起来
        {
            r->next=q;
            r=q;
            q=q->next;
        }
    }
    //如果p不空，则把后面剩余节点链接起来，即r->next=p;,否则，r->next=q;
    r->next=p?p:q;
    delete Lb;
}
```

算法复杂度分析

链表合并不需要再创建空间，只需要穿针引线，把两个单链表中的节点按非递减的顺序串联起来即可。因此在最坏的情况下，需要串联每一个节点，如果 La 和 Lb 的长度分别为 m、n 时间复杂度为 O(m+n)，空间复杂度为 O(1)。

### 就地逆置单链表

题目：将带有头节点的单链表就地逆置。即元素的顺序逆转，而辅助空间复杂度为 O(1)。

解题思路

充分利用原有的存储空间，通过修改指针实现单链表的就地逆置。还记得吗？头插法创建单链表得到的序列正好是逆序，那么我们就利用头插法建表的思路，实现就地逆置。

注意：在修改指针之前，一定要用一个辅助指针记录断点，否则后面这一部分就会遗失，再也找不到了。

```c++
void ReverseLinkList(LinkList &L)
{
    LinkList p, q;
    p=L->next;						//p指向L的第一个元素
    L->next=NULL;					//头节点的next域置空
    while(p)
    {
        q=p->next;					//q指向p的下一个节点，记录断点
        p->next=L->next;			//头插法，将L的下一个节点地址赋值给p的next域
        p=q;						//指针后移，p指向q
    }
}
```

算法复杂度分析

算法对单链表进行了一趟扫描，如果 L 的长度为 n，则时间复杂度为 O(n)，没有使用其他辅助空间，只是几个辅助指针变量，因此空间复杂度为 O(1)。

### 查找链表的中间节点

题目：带有头节点的单链表 L，设计一个尽可能高效的算法求 L 中的中间节点。

解题思路

此类题型可以使用快慢指针来解决。一个快指针，一个慢指针，快指针走两步，慢指针走一步。当快指针指向结尾的时候，慢指针刚好指向中间节点。

```c++
LinkList findmiddle(LinkList L)
{
    LinkList p, q;
    p=L;								//p为快指针，初始时指向L
    q=L;								//q为慢指针，初始时指向L
    while(p!=NULL&&p->next!=NULL)
    {
        p=p->next->next;				//p为快指针一次走两步
        q=q->next;						//q为慢指针一次走一步
    }
    return q;							//返回中间节点指针
}
```

算法复杂度分析

算法对单链表进行了一趟扫描，如果 L 的长度为 n，则时间复杂度为 O(n)，没有使用其他辅助空间，只是几个辅助指针变量，因此空间复杂度为 O(1)。

思考：如何在单链表中查找倒数第 k 个节点？

仍然可以使用快慢指针，慢指针不要动，快指针先走 k-1 步，然后两个指针一起以同样的速度走。当快指针走到终点时，慢指针正好停留在倒数第 k 个节点，为什么呢？

因为它们之间的距离始终保持 k-1。

```c++
LinkList findk(LinkList L, int k)
{
    LinkList p, q;
    p=L->next;						//p为快指针，初始时指向第一个数据元素节点
    q=L->next;						//q为慢指针，初始时指向第一个数据元素节点
    while(p->next!=NULL)
    {
        if(--k<=0)					//k减到0时，慢指针开始走
            q=q->next;				//q为慢指针
        p=p->next;					//p为快指针，先走k-1步
    }
    if(k>0)
        return NULL;
    else
        return q;					//返回中间节点指针
}
```

算法复杂度分析

算法对单链表进行了一趟扫描，如果 L 的长度为 n，则时间复杂度为 O(n)，没有使用其他辅助空间，只是几个辅助指针变量，因此空间复杂度为 O(1)。

用快慢指针还可以解决很多问题，例如判断链表是否有环，判断两个链表是否相交等。

### 删除链表中的重复元素

题目：用单链表保存 m 个整数，节点的结构为(data, next)，且|data|≤n(n 为正整数)。现要求设计一个时间复杂度尽可能高效的算法，对于链表中 data 的绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的节点。

解题思路

本题数据大小有范围限制，因此可以设置一个辅助数组记录该数据是否已出现，如果已出现，则删除；如果未出现，则标记。一趟扫描即可完成。

```c++
void Deleterep(LinkList &L)					//删除重复元素
{
    LinkList p, q;
    int x;
    int *flag=new int[n+1]					//定义flag数组，分配n+1个空间，0空间未用
    for(int i=0; i<n+1; i++)				//初始化
        flag[i]=0;
    p=L;									//指向头节点
    while(p->next!=NULL)
    {
        x=abs(p->next->data);
        if(flag[x]==0)						//未出现过
        {
            flag[x]=1;						//标记出现过
            p=p->next;						//指针后移
        }
        else
        {
            q=p->next;						//q指向p的下一个节点
            p->next=q->next;				//删除重复元素
            delete q;						//释放空间
        }
    }
    delete []flag;
}
```

算法复杂度分析

根据题意，单链表中保存 m 个绝对值小于等于 n 的整数，因此链表元素个数为 m，算法从头到尾扫描了一遍链表，时间复杂度为 O(m)；采用了辅助数组 flag[]，因为 n 为正整数，不包括 0，所以 0 空间不用，需要分配 n+1 个辅助空间，因此空间时间复杂度为 O(n)。

## 本章小结

1. 本章从数据结构三要素（逻辑结构、存储结构、运算）出发，讲解线性表。

   线性表

   - 逻辑结构

     - n 个相同类型的数据元素组成的优先序列
     - 数据之间是线性关系

   - 存储结构

     - 顺序存储：顺序表
     - 链式存储：单链表、双向链表、循环链表

   - 运算：初始化、创建、取值、查找、插入、删除

2. 顺序表和链表的比较

<table>
    <tr>
        <th colspan='2'></th>
        <th>顺序表</th>
        <th>链表</th>
    </tr>
    <tr>
    	<td rowspan='2'>空间</td>
    	<td>存储空间</td>
    	<td>预先分配，会导致空间闲置或溢出现象</td>
    	<td>动态分配，不会出现空间闲置或溢出现象</td>
    </tr>
    <tr>
    	<td>存储密度</td>
    	<td>不需要额外的存储开销表达逻辑关系，存储密度等于1</td>
    	<td>需要借助指针存储表达逻辑关系，存储密度小于1</td>
    </tr>
    <tr>
    	<td rowspan='2'>时间</td>
    	<td>存取元素</td>
    	<td>随机存取，时间复杂度为O(1)</td>
    	<td>顺序存取，时间复杂度为O(n)</td>
    </tr>
    <tr>
    	<td>插入删除</td>
    	<td>平均移动约表中一半元素，时间复杂度为O(n)</td>
    	<td>不需要移动元素，确定插入删除位置后，时间复杂度为O(1)</td>
    </tr>
    <tr>
    	<td colspan='2'>适用情况</td>
    	<td>①表长变化不大，且能事先确定变化的范围<br>②很少进行插入或删除操作，经常按元素序号访问数据元素</td>
    	<td>①长度变化交大<br>②频繁进行插入或删除操作</td>
    </tr>
</table>
3. 顺序表解题秘籍

1）位序和下标差 1，第 i 个元素的下标为 i-1。

2）移动元素时，特别注意先后顺序，以免覆盖。

3）交换元素、有序合并需要借助辅助空间。

4. 链表解题秘籍

   （1）赋值语句两端的含义

   （2）修改指针的顺序

   > 修改指针的顺序原则：先修改没有指针标记的那一端

   （3）建立链表的两种方法：头插法、尾插法。头插法是逆序建表，尾插法是正序建表。

   （4）链表逆置、归并不需要额外空间，属于就地操作。

   （5）快慢指针法：快慢指针可以解决很多问题，如链表中间节点、倒数第 k 个节点、判断链表是否有环、环的起点、公共部分的起点等。

# 栈和队列

**后进先出（Last In First Out, LIFO）**的线性序列，称为“栈”。栈也是一种线性表，只不过它是操作受限的线性表，只能在一端进出操作。进出的一端称为栈顶（top），另一端称为栈底（base）。栈可以用顺序存储，也可以用链式存储，分别称为顺序栈和链栈。

## 顺序栈

注意：栈只能在一端操作，后进先出，是人为规定的，也就是说不允许在中间查找、取值、插入、删除等操作。顺序栈本身是顺序存储的，有人就想：我偏要从中间取一个元素，不行吗？那肯定可以，但是这样做，就不是栈了。

下面讲解顺序栈的初始化、入栈，出栈，取栈顶元素等基本操作。顺序栈采用动态存储形式，元素以 int 类型为例。

### 初始化

初始化一个空栈，动态分配 Maxsize 大小的空间，用 S.top 和 S.base 指向该空间的基地址。

```c++
bool InitStact(SqStack &S)				//构造一个空栈S
{
    S.base=new int[Maxsize];			//为顺序栈分配一个最大容量为Maxsize的空位
    if(!S.base)							//空间分配失败
        return false;
    S.top=S.base;						//top初始为基地址base，当前为空栈
    return true;
}
```

### 入栈

入栈前要判断是否栈满，如果栈已满，则入栈失败；否则将元素放入栈顶，栈顶指针向上移动一个位置（top++）。

```c++
bool Push(SqStack &S, int e)				//将新元素e压入栈顶
{
    if(S.top-S.base==Maxsize)				//栈满
        return false;
    *S.top++=e;								//将新元素e压入栈顶，然后栈顶指针加1，等价于*S.top=e;S.top++;
    return true;
}
```

### 出栈

出栈前要判断是否栈空，如果栈是空的，则出栈失败；否则将栈顶元素暂存给一个变量，栈顶指针向下移动一个位置（top--）。

```c++
bool Pop(SqStack &S, int &e)				//删除S的栈顶元素，暂存在变量e中
{
    if(S.base==S.top)						//栈空
        return false;
    e=*--S.top;								//栈顶指针减1后，将栈顶元素赋值给e
    return true;
}
```

### 取栈顶元素

取栈顶元素和出栈不同。取栈顶元素只是把栈顶元素复制一份，栈顶指针未移动，栈内元素个数未变。而出栈是指栈顶指针向下移动一个位置，栈内不再包含这个元素。

```c++
int GetTop(SqStack S)						//返回S的栈顶元素，栈顶指针不变
{
    if(S.top!=S.base)						//栈非空
        return *(S.top-1);					//返回栈顶元素的值，栈顶指针不变
    else
        return -1;
}
```

## 链栈

栈可以用顺序存储，也可以用链式存储。

顺序栈是分配一段连续的空间，需要两个指针：base 指向栈底，top 指向栈顶。而链栈每个节点的地址是不连续的，只需要一个栈顶指针即可。

### 初始化

初始化一个空的链栈是不需要头节点的，因此只需要让栈顶指针为空即可。

```c++
bool InitStack(LinkStack &S)				//构造一个空栈S
{
    S=NULL;
    return true;
}
```

### 入栈

入栈是将新元素节点压入栈顶。因为链栈中第一个节点为栈顶，因此将新元素节点插到第一个节点的前面，然后修改栈顶指针指向新节点即可。有点像摞盘子，将新节点摞到栈顶之上，新节点成为新的栈顶。

```c++
bool Push(LinkStack &S,int e)				//在栈顶插入元素e
{
    LinkStack p;
    p=new Snode;							//生成新节点
    p->data=e;								//将e存入新节点数据域
    P->next=S;								//将新节点p的next指针指向S，即将S的地址赋值给新节点的指针域
    S=p;									//修改新栈顶指针为p
    return true;
}
```

### 出栈

出栈就是把栈顶元素删除，让栈顶指针指向下一个节点，然后释放该节点空间。

```c++
bool Pop(LinkStack &S, int &e)				//删除S的栈顶元素，用e保存其值
{
    LinkStack p;
    if(S==NULL)								//栈空
        return false;
    e=S->data;								//用e暂存栈顶元素数据
    p=S;									//用p保存栈顶元素地址，以备释放
    S=S->next;								//修改栈顶指针，指向下一个节点
    delete p;								//释放原栈顶元素的空间
    return true;
}
```

### 取栈顶元素

```c++
int GetTop(LinkStack S)						//返回S的栈顶元素，不修改栈顶指针
{
    if(S!=NULL)								//栈非空
        return S->data;						//返回栈顶元素的值。栈顶指针不变
    else
        return -1;
}
```

顺序栈和链栈的所有基本操作都只需要常数时间，所以在时间效率上难分伯仲。在空间效率方面，顺序栈需要预先分配固定长度的空间，有可能造成空间浪费或溢出；链栈每次只分配一个节点，除非没有内存，否则不会出现溢出，但是每个节点需要一个指针域，结构性开销增加。因此，如果元素个数变化较大，可以采用链栈；反之，可以采用顺序栈。在实际应用中，顺序栈比链栈应用更广泛。

## 顺序队列

只能从一端进，另一端出。这种先进先出（First In First Out, FIFO）的线性序列，称为“队列”。队列也是一种线性表，只不过它是操作受限的线性表，只能在两端操作：一端进，一端出。进的一端称为队尾（rear），出的一端称为队头（front）。队列可以用顺序存储，也可以用链式存储。

### 顺序队列的定义

队列的顺序存储采用一段连续的空间存储数据元素，并用两个整型变量记录队头和队尾元素的下标。

注意：队列只能在一端进、一端出，不允许在中间查找、取值、插入、删除等操作，先进先出是人为规定的，如果破坏此规则，就不是队列了。

队尾 Q.rear 超过数组的最大下标，无法再进队，但是前面有空间却出现了队满的情况，这种情况称为**“假溢出”**。

### 循环队列的定义

**队空**

```c++
Q.front==Q.rear;//Q.rear和Q.front指向同一个位置
```

**队满**

```c++
(Q.rear+1)%Maxsize==Q.front;//Q.rear向后移一位正好是Q.front
```

**入队**

```c++
Q.base[Q.rear]=x;//将元素x放入Q.rear所指空间
Q.rear=(Q.rear+1)%Maxsize;//Q.rear向后移一位
```

**出队**

```c++
e=Q.base[Q.front];//用变量记录Q.front所指元素
Q.front=(Q.front+1)%Maxsize;//Q.front向后移一位
```

**队列中元素个数**

```c++
(Q.rear-Q.front+Maxsize)%Maxsize;
```

### 循环队列的基本操作

#### 初始化

初始化循环队列时，首先分配一个大小为 Maxsize 的空间，然后令 Q.front=Q.rear=0，即队头和队尾为 0，队列为空。

```c++
bool InitQueue(SqQueue &Q)			//注意使用引用参数，否则出了函数，其改变无效
{
    Q.base=new int[Maxsize];		//分配Maxsize大小的空间
    if(!Q.base) return false;		//分配空间失败
    Q.front=Q.rear=0;				//队头和队尾置0，队列为空
    return true;
}
```

#### 入队

入队时，首先判断队列是否已满，如果已满，则入队失败；如果未满，则将新元素插入队尾，队尾后移一位。

```c++
bool EnQueue(SqQueue &Q, int e)			//将元素e放入Q的队尾
{
    if((Q.rear+1)%Maxsize==Q.front)		//队尾后移一位等于队头，表明队满
        return false;
    Q.base[Q.rear]=e;					//新元素插入队尾
    Q.rear=(Q.rear+1)%Maxsize;			//队尾后移一位
    return true;
}
```

#### 出队

出队时，首先判断队列是否为空，如果队列为空，则出队失败；如果队列不空，则用变量保存队头元素，然后队头后移一位。

```c++
bool DeQueue(SqQueue &Q, int &e)		//删除Q的队头元素，用e返回其值
{
    if(Q.front==Q.rear)
        return false;					//队空
    e=Q.base[Q.front];					//保存队头元素
    Q.front=(Q.front+1)%Maxsize;		//队头后移一位
    return true;
}
```

#### 取队头元素

```c++
int GetHead(SqQueue Q)				//返回Q的队头元素，不修改队头
{
    if(Q.front!=Q.rear)				//队列非空
        return Q.base[Q.front];
    return -1;
}
```

#### 求队列的长度

```c++
int QueueLength(SqQueue Q)
{
    return (Q.rear-Q.front+Maxsize)%Maxsize;
}
```

## 链队列

队列除了用顺序存储，也可以用链式存储。

顺序队列是分配一段连续的空间，用两个整型下标 front 和 rear 分别指向队头和队尾。而链队列类似一个单链表，需要两个指针 front 和 rear 分别指向队头和队尾。从队头出队，从队尾入队，为了出队时删除元素方便，可以增加一个头节点。

注意：链队列需要头节点。

链队列的操作和单链表一样，只不过它只能队头删除，在队尾插入，是操作受限的单链表。

### 初始化

链队列的初始化，即创建一个头节点，头指针和尾指针指向头节点。

```c++
void InitQueue(LinkQueue &Q)		//注意使用引用参数，否则出了函数，其改变无效
{
    Q.front=Q.rear=new Qnode;		//创建头节点，头指针和尾指针指向头节点
    Q.front->next=NULL;
}
```

### 入队

先创建一个新节点，将元素 e 存入该节点的数值域，然后将新节点插入队尾，尾指针后移。

```c++
void EnQueue(LinkQueue &Q, int e)		//将元素e放入队尾
{
    Qptr s;
    s=new Qnode;
    s->data=e;
    s->next=NULL;
    Q.rear->next=s;						//新节点插入队伍
    Q.rear=s;							//尾指针后移
}
```

### 出队

出队相当于删除第一个数据元素，即将第一个数据元素节点跳过去。首先用 p 指针指向第一个数据节点，然后跳过该节点，即 Q.front->next=p->next。

若队列中只有一个元素，删除后需要修改队尾指针。

```c++
bool DeQueue(LinkQueue &Q, int &e)		//删除Q的队头元素，用e返回其值
{
    Qptr p;
    if(Q.front==Q.rear)					//队空
        return false;
    p=Q.front->next;
    e=p->data;							//保存队头元素
    Q.front->next=p->next;
    if(Q.rear==p)						//若队列中只有一个元素，删除后需要修改队尾指针
        Q.rear=Q.front;
    delete p;
    return true;
}
```

### 取队头元素

队头实际上是 Q.front->next 指向的节点，即第一个数据节点，队头元素就是将该节点的数据域存储的元素。

```c++
int GetHead(LinkQueue Q)				//返回Q的队头元素，不修改队头指针
{
    if(Q.front!=Q.rear)					//队列非空
        return Q.front->next->data;
    return -1;
}
```

## 栈和队列的应用

### 数制的转换

题目：将一个十进制数 n 转换为二进制数。

解题思路

十进制数转换为二进制，可以采用辗转相除、取余数的方法得到。例如十进制数 11 转二进制。先求余数 11%2=1，求商 11/2=5，然后用商 5 再求余数，求商，直到商为 0，结束。

11%2=1 11/2=5
5%2=1 5/2=2
2%2=0 2/2=1
1%2=1 1/2=0

先求出的余数是二进制数的低位，后求出的余数是二进制数的高位，将得到的余数逆序输出就是所要的二进制数，即 11 的二进制数为 1011。如何将余数逆序输出呢？逆序输出正好符合栈的先入后出性质，因此可以借助栈来实现。

算法步骤

1）初始化一个栈 S。
2）如果 n! =0，将 n%2 入栈 S，更新 n=n/2。
3）重复运行第 2 步，直到 n=0 为止。
4）如果栈不空，弹出栈顶元素 e，输出 e，直到栈空。

```c++
void binaryconversion(int n)
{
    SqStack S;//定义一个栈S
    int e;
    InitStack(S);//初始化一个空栈
    while(n)//n不为0时，一直循环
    {
        Push(S,n%2);//入栈
        n=n/2;//更新
    }
    whie(!Empty(S))//如果栈不空
    {
        Pop(S,e);//出栈
        cout<<e<<'\t';//输出栈顶元素
    }
}
```

算法复杂度分析

每次取余后除以 2, n 除以 2 多少次变为 1，那么第一个 while 语句就执行多少次。假设执行 x 次，则 n/2x=1, x=㏒₂n。因此，时间复杂度为 O(㏒₂n)，使用的栈空间大小也是 ㏒₂n，空间复杂度也为 O(㏒₂n)。

### 回文判定

题目：回文是指正读反读均相同的字符序列，如“abba”和“abcscba”均是回文，也就是说字符串沿中心线对称，如图 3-55 所示，但“foot”和“bed”不是回文。试写一个算法判定给定的字符串是否为回文。

解题思路

回文是中心对称的，可以将字符串前一半入栈，然后，栈中元素和字符串后一半进行比较。即将第一个出栈元素和后一半串中第一个字符比较，若相等，则再将出栈一个元素与后一个字符比较……直到栈空为止，则字符序列是回文。在出栈元素与串中字符比较不等时，则字符序列不是回文。

算法步骤

1）初始化一个栈 S。
2）求字符串长度，将前面一半的字符依次入栈 S。
3）如果栈不空，弹出栈顶元素 e，与字符串后一半元素比较。若 n 为奇数，则跳过中心点，比较中心点后面的元素。如果元素相等，则继续比较直到栈空，返回 true；如果元素不等，返回 false。

```c++
bool palindrome(char *str)//判断字符串是否为回文
{
    SqStack S;//定义一个栈S
    int len, i;
    char e;
    len=strlen(str);//返回字符串长度
    InitStack(S);//初始化栈
    for(i=0; i<len/2; i++)//将字符串前一半依次入栈
        Push(S,str[i]);
    if(len%2==1)//字符串长度为奇数，跳过中心点
        i++;
    while(!Empty(S))//如果栈不空
    {
        Pop(S,e);//出栈
        if(e!=str[i])//比较元素是否相等
            return false;
        else
            i++
    }
    return true;
}
```

算法复杂度分析

如果字符串长度为 n，将前一半入栈，后一半依次和出栈元素比较，相当于扫描了整个字符串，因此时间复杂度为 O(n)，使用的栈空间大小是 n/2，空间复杂度也为 O(n)。

### 双端队列

题目：设计一个数据结构，使其具有栈和队列两种特性。

解题思路

栈是后进先出，队列是先进先出，如何具有这两种特性呢？

栈是在一端进出，队列是在一端进、另一端出，能否设计两端都可以进出呢？

允许两端都可以进行入队和出队的队列，就是双端队列。

#### 双端队列结构体定义
