# 【阿里】如何实现页面文本不可复制

有 CSS 和 JS 两种方法，以下任选其一或结合使用

使用 CSS 如下：

```css
user-select: none;
```

或使用 JS 如下，监听 `selectstart` 事件，禁止选中。

当用户选中一片区域时，将触发 `selectstart` 事件，Selection API 将会选中一片区域。禁止选中区域即可实现页面文本不可复制。

```javascript
document.body.onselectstart = (e) => {
  e.preventDefault()
}

document.body.oncopy = (e) => {
  e.preventDefault()
}
```

# 【字节】简单介绍 requestIdleCallback 及使用场景

`requestIdleCallback` 维护一个队列，将在浏览器空闲时间内执行。它属于 Background Tasks API，你可以使用 `setTimeout` 来模拟实现

```javascript
window.requestIdleCallback =
  window.requestIdleCallback ||
  function (handler) {
    let startTime = Date.now()

    return setTimeout(function () {
      handler({
        didTimeout: false,
        timeRemaining: function () {
          return Math.max(0, 50.0 - (Date.now() - startTime))
        },
      })
    }, 1)
  }
```

可以在 `ric` 中执行任务时需要注意以下几点：

1. 执行重计算而非紧急任务
2. 空闲回调执行时间应该小于 50ms，最好更少
3. 空闲回调中不要操作 DOM，因为它本来就是利用的重拍重绘后的间隙空闲时间，重新操作 DOM 又会造成重拍重绘

# 【头条】前端上传文件时如何读取文件内容

```
<input type="file" id="input" onchange="handleFiles(this.files)">
```

在浏览器中，通过 `input[type=file]` 来点击上传文件，此时监听 `onChange` 事件，可以获取到 `File` 对象，其中从中可以读取文件内容

而读取文件内容，需要转化 `File/Blob` 到 `Text`，一般使用以下两种方案

## **FileReader API**

这是最常用处理上传文件的 API，但是却繁琐冗余难记，每次使用基本上都要查文档！

`FileReader API` 用以读取 File/Blob 内容，正因为繁琐难记，以下实现一个 `readBlob` 函数读取内容。

```javascript
function readBlob(blob) {
  return new Promise((resolve) => {
    const reader = new FileReader()
    reader.onload = function (e) {
      resolve(e.target.result)
    }
    reader.readAsText(blob)
  })
}
```

## **Response API**

而是用 `Response API` 只需要一行内容

```javascript
const readBlob = (blob) => new Response(blob).text()
```

# 如何通过实践项目来提升自己的前端技能？

1. 选中具体的项目目标
2. 制定项目计划和路线图
3. 使用新技术和工具
4. 注重用户体验和设计
5. 模块化和组件化开发
6. 版本控制和协作
7. 不断迭代和改进

# 你在工作中最注重的是什么？

1. 用户体验
2. 性能优化
3. 新技术和创新
4. 团队合作

# 箭头函数

1. 不能使用 new 调用（不能当作构造函数）

2. 没有原型， 即没有 `prototype` 属性

3. 没有 arguments

4. 没有 this

   箭头函数中的 this 是在箭头函数定义时就决定的，而且不可修改的（call、apply、bind）

   箭头函数的 this 指向定义时，外层中第一个普通函数的 this

# computed、methods、watch 有什么区别？

1. computed 和 methods 的区别

   computed 是有缓存的，methods 没有缓存

2. computed 和 watch 的区别

   watch 是监听，数据或者路由发生了改变才可以响应（执行）

   computed 计算某一个属性的改变，如果某一个值改变了，计算属性会监测到进行返回

   watch 是当前监听到数据改变了，才会执行内部代码

# var let const

都是用来声明变量

区别一：

var 具有变量提升机制，let 和 const 没有变量提升的机制

区别二：

var 可以多次声明同一个变量，let 和 const 不可以多次声明同一个变量

区别三：

var、let 声明变量的，const 声明常量

var 和 let 声明的变量可以再次赋值，但是 const 不可以再次赋值

区别四：块级作用域

var 声明的变量没有自身作用域，let 和 const 声明的变量有自身的作用域

var 声明的变量被挂到 window

# computed 的值可以用 v-model 绑定吗？

不可以。准确地说，用 v-model 绑定了 computed 的值后，可以在绑定的元素中得到 computed 的结果，但不能实现双向绑定。

v-model 通常用来绑定 input、select 等标签，目的是为了实现双向绑定，当原始属性发生变化时，绑定标签的值也会发生变化；当标签的值发生变化时，原始属性同样变化。而 computed 是通过原始属性计算出的结果，是单向只读的，不能直接修改。

# mutations 和 actions 区别

action 提交的是 mutation，而不是直接变更状态

action 可以包含任意异步操作

# JS 中的计时器是否能精确计时？为什么？

1. 硬件

   原子钟

2. 系统

   操作系统的计时

3. 标准 w3c

   setTimeout `>=5` 的嵌套层级，最小 4ms

4. 事件循环

# ref 与 toRef 的区别是什么？

1. ref 本质是将原数据进行拷贝，然后通过 proxy 转为响应式数据；所以不管是修改原数据还是修改响应式数据，它们是不会受到影响的
2. toRef 本质是将一个对象的一个属性，通过 ref 转为响应式数据，是引用关系；且不管是修改源数据还是修改 toRef 后的数据，两者都会改变
3. ref 数据发生变化后，界面会马上更新；toRef 数据发生变化后，界面不会自动更新
4. ref 方法只接收一个参数，toRef 接收两个参数

# vue3 如何实现一个组件的异步加载？

1. Suspense
2. defineAsyncComponent

# 如何创建一个没有 prototype 的对象？

Object.create(null)

# 前端性能优化的手段？

1. 减少重绘和回流
   - 使用 transform 和 opacity 替代 position、width 和 height 来进行动画
   - 使用 will-change 来提前告知浏览器某个属性将要发生变化
2. 减少 HTTP 请求：
   - 合并和压缩 css、JavaScript 和图像文件
   - 使用字体图标代替图像
3. 使用缓存
   - 利用浏览器缓存机制，设置合适的缓存头
   - 利用 Service Workers 实现离线缓存
4. 异步加载资源
   - 将脚本移到页面底部
   - 使用异步加载脚本或延迟加载脚本
5. 优化图像
   - 使用适当的图像格式
   - 压缩图像以减小文件大小
   - 使用图像懒加载，仅加载用户可见区域的图像
6. 优化 CSS 和 JavaScrip
   - 合并和压缩 css、JavaScript 文件
   - 移除不必要的注释和空白
   - 使用 Tree-shaking（对于 JavaScript）来去除未使用的代码
7. 使用 CDN（内容分发网络）
   - 将静态资源部署到全球 CDN 上，减少网络延迟
8. 懒加载和分块加载
   - 使用懒加载加载视口内的内容
   - 使用按需加载（Code Splitting）分割大型 JavaScript 文件
9. 优化字体加载
   - 仅加载页面所需的字体变体
   - 使用 font-display: swap 属性来优化字体加载

# 如何将一个字符串转为二进制？

1. 将字符串转为字符数组
2. 遍历字符数组，使用 charCodeAt() 将每个字符元素转为 ASCII 码
3. 使用 toString(2) 将 ASCII 码元素转为二进制
4. 使用 join() 拼接数组元素，转为二进制字符串

# 严格模式下有哪些限制？

- 变量必须声明后再使用
- 不能使用 with 语句
- 禁止 this 指向 window
- 不能删除变量
- 禁止在函数内部遍历调用栈
- 禁止使用 arguments.callee

# find 和 filter 的区别

区别一：返回的内容不同

filter 返回的是新数组

find 返回的是具体的内容

区别二：

find：匹配到第一个即返回

filter：返回整体（每一个匹配到的都返回）

# some 和 every 的区别

some 如果有一项匹配则返回 true

every 全部匹配才会返回 true

# 如何判断一个数据是否可以转成日期？

方法一：用 new Date() 方法，将数据转换成日期对象，转换失败的值是字符串 "Invalid Date"

方法二：用 new Date() 方法，将数据转换成日期对象，再用 getTime() 方法，获取该日期的时间戳，最后用 isNaN() 判断该时间戳是否为一个数组

# 如何关闭 ios 键盘首字母自动大写

`<input type="text" autocapoitalize="off" />`

# 如何检测一个数组中是否包含某一个元素？

1. indexOf 返回元素下标，没有返回 -1
2. find 查找并返回目标元素，没有 undefined
3. findIndex 查找并返回目标元素下标，没有返回 -1
4. some 查找数组中是否有符合条件的元素，返回 true/false
5. includes 返回数组是否包含指定的元素，返回 true/false

# 微信小程序面试题：组件与普通页面有什么不同？

1. 组件的 .js 文件执行的 Component() 函数，页面 .js 文件执行的是 Page() 函数
2. 组件在 .json 文件中必须声明 "component": true 属性
3. 组件的事件处理函数需要定义到 methods 节点中
4. 生命周期不同

# rgba 和 opacity 都可以设置透明度，它们有什么不同？

1. rgba 指的是颜色，rgb 分别是红、绿、蓝，a 指 Alpha 透明度。所以 rgba 只能作用于颜色；而 opacity 作用于整个元素
2. opacity 会被子元素继承；rgba 不会

# 判断奇数

```javascript
function isOdd(n) {
  return n % 2 === 1 || n % 2 === -1
}
```

# 判断函数是否标记为 async

```javascript
function isAsyncFunction(func) {
  return Object.prototype.toString.call(func) === '[object AsyncFunction]'
}
```

# 匹配字符

```javascript
let reg = new RegExp(key, 'gi')
str.replace(reg, '替换值或回调函数')
```

# 键盘事件

键盘事件由用户击打键盘触发，主要有 keydown、keypress、keyup 三个事件：

keydown：按下键盘时触发

keyup：松开键盘时触发该事件

keypress：按下有值的键时触发。即按下 ctrl alt shift meta 这样的无值的键，这个事件不会触发

对于有值的键，按下时先触发 keydown 事件，再触发这个事件。

# 如何实现自适应布局

无限适配方案 + rem 单位

无限适配的核心原理：把屏幕划分为一定的份数（10 份），通过 JS 动态监测屏幕尺寸宽度，实时计算并设置 html 元素的基础字体大小

# 响应式设计

网站在不同的设备和屏幕尺寸上都可以提供一致的用户体验

原理：

1. 弹性和网格布局
2. 弹性图片：图片会根据屏幕大小进行调整
3. 媒体查询
4. 流式布局
5. 适应图片

# CDN

CDN：内容分发网络，是一组分布在世界各地的服务器网络，可以为全球用户提供快速、安全的内容传送服务

原理：

1. CDN 服务器在全球各地分布
2. 用户访问网站的时候，用户浏览器会向最近的 CDN 发送请求
3. CDN 服务会把内容缓存在离用户最近的服务器上面，把内容返回给用户

作用：

1. 提高页面的加载速度
2. 减轻源服务器的负担
3. 提高网站的可用性

# 文字转语音

如何把文字转语音

web api：语音不统一/兼容性

第三方平台

优化：

断句

并发控制

缓存

客户端 localStorage（md5 base64）

服务器

# 重绘和回流有什么区别？

1. 重绘
   - 元素样式的可见属性发生改变（颜色、背景色），但布局不改变的时候
   - 重绘不影响页面布局，只会重绘受影响的元素
2. 回流
   - 布局的变化导致元素的尺寸、位置或隐藏状态的变化，需要重新计算整个布局
   - 回流会造成重绘，但重绘不一定会回流

css3 硬件加速

批量操作元素，然后再使用文档碎片进行操作

缓存样式属性

# CSS 中的 important 规则有什么特殊性？何时应避免使用？

特殊性：

    1. 打破了 css 层叠关系和继承规则
    1. 出现多次时，后者覆盖前者

何时避免使用：

    1. 尽量避免使用
    1. 大型项目
    1. 覆盖样式尽量使用选择器

# SPA 的优缺点，以及在何种场景下更适合使用 SPA

优点：

用户体验好

性能好

前后端分离

组件化和模块化

更好的客户逻辑处理

缺点：

初始化加载时间比较长

SEO 问题比较严重

复杂性比较高

不利于离线浏览

场景：

项目侧重于用户体验

对于一些需要保持高度一致性的 UI 设计和交互

对项目有足够的资源投入，并且可以承担初始化加载时间较长

# 从输入 URL 到页面展现这一过程中，浏览器都做了哪些工作

1. 解析 URL
2. 查找缓存
3. DNS 查询
4. 建立 TCP 链接
5. 发送 HTTP 请求
6. 服务器处理请求
7. 服务器发送 HTTP 响应
8. 浏览器接收并解析响应
9. 资源加载与渲染
10. 布局和绘制
11. JS 执行
12. 交互与更新

# 如何避免 JavaScript 中的全局变量污染？

1. 立即执行函数
2. 严格模式

# window.onload 和 DOMContentLoaded 的区别

都是用来标识 DOM 文档加载完成的事件

1. 加载时机：
   1. window.onload 页面所有 DOM 加载完成后触发
   2. DOMContentLoaded 在 DOM 树构建完成后触发
2. 事件是否能多次触发：
   1. window.onload 不行
   2. DOMContentLoaded 可以
3. 兼容性
   1. window.onload IE8 以下不支持
   2. DOMContentLoaded IE9 以上才支持

# 谈谈移动端布局的几种方式

1. 流式布局

   相对单位定义元素的宽高

2. 固定宽度布局

3. 响应式布局

   弹性布局+媒体查询

4. 栅格布局

5. flex 布局（弹性布局）

6. 瀑布流

# 点击穿透

在进行快速滑动的时候，某个可点击元素的点击事件透过了当前元素传递到了下方元素

1. 阻止默认事件

   e.preventDefault()

2. 使用 touch 事件

3. 使用第三方库

   fastclick zepto

4. css

# rem 和 em 的区别是什么？

1. rem

   相对于根元素的字体大小来计算的

   根元素的 font-size：16px，另外一个元素 width:1rem

2. em

   em 相对于当前元素的字体大小来计算

   如果父元素设置了字体大小，子元素使用 em 单位，它的大小会受到父元素字体大小的影响

# 清除浮动的方法有哪些？伪元素清除的原理是什么？

1. 额外标签法

   浮动元素之后添加一个空 div 或其他块级元素，并设置 clear:both

2. 使用 overflow 属性触发 BFC

   浮动元素的父容器上设置 overflow:hidden

3. 伪元素清除法

   利用 after 伪元素为浮动元素的父容器添加看不见的内容，然后设置 clear:both;display:block;content:''

4. 直接设置高度

# BFC 是什么？它可以解决什么问题？

块级格式化上下文

浏览器在渲染过程中用于组织块级元素的一个独立渲染区域

触发 BFC 的条件

    1. float 值不为 None 的元素
    1. position 的值为 absolute/fixed 的元素
    1. display 值为 inline-block/table-cell/table-caption/grid/flex 等非默认块级显示模式的元素
    1. overflow 的值不是 visible 的块级元素

解决问题：

    1. 外边距合并
    1. 浮动元素的影响
    1. 文字环绕效果
    1. 防止外边距穿透

# forEach

```javascript
const arr = [1, 2, 3]
arr.forEach((item) => {
  arr.push(2)
  console.log('arr', item)
})

arr.forEach((item, i) => {
  arr.splice(i, 1)
  console.log('arr', item)
})

const arr1 = [, , 3]
arr1.forEach((item) => {
  console.log('arr', item)
})
```

```javascript
Array.prototype.forEach = function (callback) {
  const len = this.length
  if (typeof callback !== 'function') {
    throw new TypeError(callback + 'is not a function')
  }
  let k = 0
  while (k < len) {
    if (k in ths) {
      callback(this[k], k, this)
    }
    k++
  }
}
```

# 立即执行函数

```javascript
;(function test() {
  test = 'LBJhui'
  console.log(test)
})()
// 函数的名称是只读的，所以不能在函数内部修改函数的名称。因此函数内部 test = 'LBJhui' 这行代码其实是无效的
```

# 在前端开发中如何优化 DOM 操作以提高页面性能

1. 减少 DOM 查询
2. 批量处理 DOM 操作
3. 避免不必要的重排重绘
4. 使用现代 api
5. 异步编程和延迟加载
6. 使用原生方法替代字符串操作
7. 事件委托

# CORS 的工作原理是什么？

预检请求

服务器响应

实际请求和响应

浏览器检验

# JSONP 是什么？它是如何绕过同源策略的

利用浏览器对 script 标签的特殊处理来规避同源策略的限制

原理核心：

机制

- 客户端请求
- 服务端响应
- 客户端处理

绕过同源策略

场景限制：GET

# scoped 原理

1. 作用：让样式在本组件中生效，不影响其他组件
2. 原理：给结点新增自定义属性，然后 css 根据属性选择器添加样式

# 什么是 XSS 攻击？如何防止 XSS 攻击？

XSS：指攻击者通过在目标网站输入字段中注入恶意脚本代码，当其他用户浏览这个网站的时候，脚本会在他的浏览器中执行，获取用户的敏感信息。

防止措施：

1. 输入验证和过滤
2. 输出编码
3. 使用 HTTP 头部设置
4. 妥善管理 cookies
5. 建立安全的开发实践
6. 更新和软件升级

# Vue 路由模式

路由模式有两种：history、hash

区别：

1. 表现形态不同
2. 跳转请求，路径不存在时，history 会发送请求，hash 不会发送请求
3. 打包后前端自测要使用 hash，如果使用 history 会出现空白页

# 介绍一下 SPA 以及 SPA 有什么缺点

SPA 是什么？单页面应用

缺点：

1. SEO 优化不好
2. 性能不是特别好

# 在处理跨域时，如果考虑安全性因素

1. 精确控制允许的源
2. 限制请求方法和头信息
3. 预检请求验证
4. 使用 https
5. 设置适当的 CSP 策略
6. 验证和过滤请求数据
7. 限制第三方 API 使用
8. 实施速率限制
9. 日志和监控

# post 请求和 get 请求在跨域时有何不同？

当涉及到跨域请求（Cross-Origin Requests）时，POST 请求和 GET 请求之间存在一些关键的不同点，特别是在处理浏览器中的 CORS（跨来源资源共享）策略时。以下是它们之间的主要差异：

1. **预检请求（Preflight Request）**：

   - 对于某些 CORS 请求，浏览器会首先发送一个 OPTIONS 请求作为预检请求，以检查服务器是否允许跨域请求。这通常发生在“非简单请求”中，即那些不符合简单请求条件的请求。简单请求的条件包括：请求方法只能是 HEAD、GET 或 POST，请求头只能包含一些特定的字段（如 Accept、Accept-Language、Content-Language、Content-Type 等），且 Content-Type 的值仅限于`application/x-www-form-urlencoded`、`multipart/form-data`或`text/plain`。
   - 对于 POST 请求，如果它包含自定义的 HTTP 头或 Content-Type 字段的值不是上述的“简单”值，那么它通常会触发预检请求。而 GET 请求由于其性质（通常只用于检索数据）和简单性，很少会触发预检请求。

2. **缓存**：

   - 浏览器可能会对 GET 请求的响应进行缓存，这意味着对于相同的 URL 和请求头，浏览器可能会从缓存中加载响应而不是重新发送请求到服务器。但是，POST 请求通常不会被缓存，因为它们是用于提交数据的，而数据可能会经常变化。
   - 在跨域场景中，这种缓存行为可能会影响请求的性能和结果。如果 GET 请求的响应被缓存，并且服务器上的数据已经更改，那么客户端可能会获取到旧的、不准确的数据。

3. **安全性**：

   - 从安全性的角度来看，POST 请求通常用于提交数据（如表单数据、文件上传等），而 GET 请求则用于检索数据。因此，在跨域场景中，使用 POST 请求提交敏感数据可能更安全一些，因为它不太可能被缓存或记录在浏览器的历史记录中。但是，这并不意味着 POST 请求本身就更安全；它仍然需要适当的安全措施（如 HTTPS、身份验证和授权等）来保护数据。

4. **请求体（Request Body）**：

   - GET 请求通常没有请求体（尽管某些 HTTP 客户端和服务器可能允许在 GET 请求中包含请求体，但这并不是标准做法）。因此，跨域 GET 请求不能用于发送大量数据到服务器。相反，POST 请求可以包含请求体，并用于发送大量数据到服务器。

5. **幂等性**：

   - GET 请求是幂等的，即多次执行相同的 GET 请求不会产生不同的结果（除非有副作用，如数据更新或删除）。这使得 GET 请求在跨域场景中更加可靠和可预测。相比之下，POST 请求通常不是幂等的，因为每次执行 POST 请求都可能会产生不同的结果（例如，创建新的资源或更新现有资源）。

6. **浏览器限制**：

   - 某些浏览器可能会对 GET 请求的 URL 长度施加限制（尽管这个限制可能因浏览器和版本而异）。如果 URL 超过了这个限制，那么 GET 请求可能会失败。相比之下，POST 请求没有这样的限制，因为数据可以包含在请求体中而不是 URL 中。因此，在需要发送大量数据或复杂查询参数的跨域场景中，POST 请求可能更合适。

# 解释一下 CSP 与跨域的关系

CSP（Content Security Policy）与跨域（Cross-Origin）在 Web 安全领域中是两个重要的概念，但它们各自关注的安全问题和实现机制有所不同。以下是关于 CSP 与跨域关系的详细解释：

### CSP（内容安全策略）

1. **定义**：CSP 是为了缓解跨站脚本（XSS）等安全威胁而引入的一种安全机制。它允许网站开发者创建并强制应用一些规则，以管理网站允许加载的内容。
2. **工作原理**：CSP 以白名单的机制对网站加载或执行的资源起作用。在网页中，这样的策略通过 HTTP 头信息或者 meta 元素定义。例如，通过设置`Content-Security-Policy` HTTP 头，可以限制哪些外部资源（如脚本、样式表、图片等）可以被加载和执行。
3. **限制与影响**：CSP 虽然提供了强大的安全保护，但也可能造成一些限制，如 Eval 及相关函数被禁用、内嵌的 JavaScript 代码将不会执行、只能通过白名单来加载远程脚本等。这些限制可能会增加开发者的工作量，需要花费更多时间来分离内嵌的 JavaScript 代码和调整应用逻辑。

### 跨域（Cross-Origin）

1. **定义**：跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。由于浏览器的同源策略（Same-Origin Policy），跨域请求通常会被限制或阻止，以防止恶意脚本攻击和数据泄露。
2. **同源策略**：同源策略要求协议、域名和端口三者都相同才被认为是同源的。如果其中任何一个不同，则被视为跨域。
3. **解决方案**：为了实现跨域请求，开发者可以采用一些技术手段，如 CORS（跨来源资源共享）、Proxy（代理）和 JSONP 等。这些技术允许服务器设置特定的响应头（如`Access-Control-Allow-Origin`），以允许来自不同源的请求。

### CSP 与跨域的关系

- **独立性**：CSP 和跨域是两个独立的概念，各自关注不同的安全问题。CSP 关注的是如何限制和管理网站加载的内容，而跨域关注的是如何允许或限制来自不同源的请求。
- **相互影响**：在某些情况下，CSP 的设置可能会影响跨域请求的实现。例如，在使用 CSP 限制脚本加载时，如果跨域请求需要加载并执行远程脚本，可能会受到 CSP 策略的限制。同样，跨域请求的实现也可能需要考虑 CSP 策略的影响，以确保请求的资源符合 CSP 规则。

综上所述，CSP 和跨域在 Web 安全领域中各自扮演着重要的角色。开发者需要根据实际需求合理配置 CSP 策略和跨域请求的实现方式，以确保 Web 应用的安全性和可用性。

# link 和@import 导入外部样式表有何区别？

在前端开发中，`link`和`@import`都是用于导入外部样式表的方法，但它们之间存在一些关键的区别。以下是两者的主要区别：

1. **语法与用法**：

   - `link`：是一个 HTML 标签，它可以直接在 HTML 文档中使用，通过`href`属性指定外部样式表的 URL。例如：`<link rel="stylesheet" href="styles.css">`。
   - `@import`：是 CSS 的一个指令，它只能在 CSS 文件中使用，通过`@import`关键字和`url()`函数指定外部样式表的 URL。例如：`@import url("styles.css");`。

2. **加载顺序**：

   - `link`：在页面加载时，浏览器会同时加载和渲染`link`引用的外部样式表。
   - `@import`：浏览器会在整个页面和 CSS 文件加载完成后，再加载`@import`引用的外部样式表。这可能会导致页面渲染的延迟。

3. **兼容性**：

   - `link`：在所有现代浏览器中都有良好的兼容性。
   - `@import`：虽然大多数现代浏览器都支持`@import`，但在一些较旧的浏览器中可能存在兼容性问题，特别是旧版本的 Internet Explorer。

4. **权重与覆盖**：

   - 由于`link`引用的样式表在页面加载时即被加载和渲染，因此它们具有更高的权重。如果有相同的样式规则，`link`引用的样式表将覆盖`@import`引用的样式表中的规则。

5. **使用场景**：

   - `link`：更常用，特别是在 HTML 文档中直接引用外部样式表时。它也支持在 HTML 中同时引用多个外部样式表。
   - `@import`：可以在 CSS 文件中使用，以引入其他 CSS 文件或媒体查询。然而，由于加载顺序和兼容性问题，它的使用场景相对较少。

6. **性能考虑**：
   - 使用`@import`可能会导致页面渲染的延迟，因为它是在页面和 CSS 文件加载完成后才加载样式表的。这可能会影响到用户体验。
   - 另一方面，`link`标签由于在页面加载时即加载样式表，因此通常具有更好的性能。

综上所述，尽管`@import`和`link`都可以用于导入外部样式表，但在实际开发中，`link`标签由于更好的兼容性、加载顺序和性能，通常被更广泛地使用。
