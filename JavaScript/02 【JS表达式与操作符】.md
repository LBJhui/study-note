### 1.3 有关 IEEE754

在 JS 中，有些小数的数学运算不是很精准。

```js
0.1 + 0.2 // 0.30000000000000004
```

JS 使用了 IEEE754 二进制浮点数算术标准，这会使一些个别的小数运算产生 “丢失精度” 问题。

注意：不是所有的小数运算都会出现精度问题，只是少数部分。

> 几乎所有的高级语言都使用了 IEEE754 二进制浮点数算术标准。
>
> IEEE754 二进制浮点数算术标准是计算机底层编译标准，了解即可！

【解决办法】

在进行小数运算时，要调用数字的 `toFixed()` 方法保留指定的小数位数。

> `toFixed()` 括号内接受一个保留小数位数的参数。

```js
;(0.1 + 0.2).toFixed(2) // '0.30'，默认得到一个字符串值
Number((0.1 + 0.2).toFixed(2)) // 0.3
```

> `toFixed()` 遵循 “四舍五入” 原则。
>
> ```js
> ;(0.9945).toFixed(3) // "0.995"
> ```

> 最后要注意浮点数的相等比较：
>
> ```js
> 1 / 3 === 1 - 2 / 3 // false
> ```
>
> 这不是 JavaScript 的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：
>
> ```js
> Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001 // true
> ```

> 还有一种解决技巧，就是将浮点数转换为整数进行计算：
>
> ```js
> 0.1 + 0.2 // 0.30000000000000004
> ;(0.1 * 10 + 0.2 * 10) / 10 // 0.3
> ```

### 1.4 幂和开根号

JS 中没有提供幂运算、开根号的运算符，需要使用 Math 对象的相关方法进行计算。

`Math.pow(a, b)`：求 a 的 b 次方。

`Math.sqrt(a)`：求 a 的平方根。

```js
Math.pow(2, 3) // 8
Math.pow(3, 2) // 9
Math.sqrt(81) // 9
Math.sqrt(-81) // NaN
```

### 1.5 向上取整和向下取整

`Math.ceil()`：向上取整。

`Math.floor()`：向下取整。

`Math.round()`：把一个数字舍入为最接近的整数（“四舍六入”，“五不一定”）

> 注意：向上、向下的标准是：X 轴正方向为上！
>
> 负 ———— 0 ————> 正

```js
Math.ceil(2.4) // 3
Math.floor(2.4) // 2

Math.ceil(-2.4) // -2
Math.floor(-2.4) // -3

Math.ceil(2) // 2
Math.floor(2) // 2
```

## 2 系表达式

### 2.1 关系运算符

| 意义       | 运算符 |
| ---------- | ------ |
| 大于       | `>`    |
| 小于       | `<`    |
| 大于或等于 | `>=`   |
| 小于或等于 | `<=`   |
| 等于       | `==`   |
| 不等于     | `!=`   |
| 全等于     | `===`  |
| 不全等于   | `!==`  |

### 2.2 相等和全等

两个等号 `==` 运算符，不考虑值的类型，它会进行隐式转换后比较值的字面量是否相等。

三个等号 `===` 运算符，不仅比较值是否相同，也比较类型是否相同。

```js
5 == '5' // true
5 === '5' // false
1 == true // true
1 === true // false

0 == false // true
0 === false // false

0 == undefined // false
0 === undefined // false

undefined == null // true
undefined === null // false
```

> null 和 undefined 用 == 进行比较涉及隐式强制类型转换，ES5 规范中规定。
>
> === 比较为 false，是因为 null 与 undefined 类型不同。
>
> 建议没有特殊情况请一律使用 ===

### 2.3 NaN 不自等

NaN 作为一个特殊的数字类型值，它在用 `==` 比较的时候也有特殊的结果。

```js
NaN == NaN // false
NaN === NaN // false
```

【如何判断某变量值为 NaN】

`isNaN()` 函数可以用来判断变量值是否为 NaN。

```js
isNaN(NaN) // true
isNaN(5) // false
isNaN('5') // false
```

> 但 isNaN() 也不好用，它的机理是：只要该变量传入 Number() 的执行结果是 NaN，则 isNaN() 函数都会得到 true。
>
> 对于，undefined 和 null，这种情况一般来说需要先进行单独判断，再进行 isNaN 判断。
>
> ```js
> isNaN(undefined) // true
> isNaN('3天') // true
> isNaN(null) // false
> ```

### 2.4 JS 中没有连比

例如：`3 <= a <= 15` 的写法是错误的，应该为：`a >= 3 && a <= 15`。

## 3.逻辑表达式

### 3.1 逻辑运算符

| 意义 | 运算符 |
| ---- | ------ | --- | --- |
| 非   | `!`    |
| 与   | `&&`   |
| 或   | `      |     | `   |

### 3.2 非运算

`!` 表示 “非”，也可以称为 “置反运算”。

`!` 是一个 “单目运算符”，只需要一个操作数。

置反运算的结果一定是布尔值。

```js
!true // false
!false // true
!0 // true
!undefined // true
!'' // true
!' ' // false
!null // true
!'imooc' // false
```

> `!!` 常用于确定一个值的布尔属性。
>
> ```js
> !!true // true
> !!0 // false
> !!'' // false
> !!' ' // true
> !!'imooc' // true
> ```

### 3.3 与运算

`&&` 是 “双目运算符”。

核心：`全真为真、有假即假`。

### 3.4 或运算

`||` 是 “双目运算符”。

核心：`全假为假、有真即真`。

### 3.5 短路运算

`&&` 与 `||`，都属于 “短路运算符”。

（1）`&&` 短路运算

由于 `&&` 运算的核心是：“全真为真、有假即假”，所以：

- 如果 `a && b` 中 `a` 为真，那么该表达式的值由 `b` 决定（计算 a 又计算 b）
- 如果 `a && b` 中 `a` 为假，那么该表达式的值由 `a` 决定（只计算 a）

```js
3 && 6 // 6
undefined && 15 // undefined
15 && undefined // undefined
null && 2 // null
'' && 16 // ''
NaN && undefined // NaN
```

（2）`||` 短路运算

由于 `||` 运算的核心是：“全假为假、有真即真”，所以：

- 如果 `a || b` 中 `a` 为真，那么该表达式的值由 `a` 决定（只计算 a）
- 如果 `a || b` 中 `a` 为假，那么该表达式的值由 `b` 决定（计算 a 又计算 b）

```js
3 || 6 // 3
0 || 6 // 6
null || undefined // undefined
'a' || 'b' // 'a'
NaN || null // null
```

### 3.6 逻辑运算的优先级

优先级：`!` > `&&` > `||`

```js
!true || true;		// true
3 && 4 || 5 && 6；  // 4
```

> 推荐使用 `()` 来规定优先级。
